#### [1470. 重新排列数组](https://leetcode.cn/problems/shuffle-the-array/)

难度简单

给你一个数组  `nums`  ，数组中有  `2n`  个元素，按  `[x1,x2,...,xn,y1,y2,...,yn]`  的格式排列。

请你将数组按  `[x1,y1,x2,y2,...,xn,yn]`  格式重新排列，返回重排后的数组。

**示例 1：**
```
输入：nums = [2,5,1,3,4,7], n = 3
输出：[2,3,5,4,1,7] 
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
```
**示例 2：**
```
输入：nums = [1,2,3,4,4,3,2,1], n = 4
输出：[1,4,2,3,3,2,4,1]
```
**示例 3：**
```
输入：nums = [1,1,2,2], n = 2
输出：[1,2,1,2]
```
**提示：**

-   `1 <= n <= 500`
-   `nums.length == 2n`
-   `1 <= nums[i] <= 10^3`

#### 方法一
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> ans(2 * n);
        for (int i = 0; i < n; i++) {
            ans[2 * i] = nums[i];
        }
        for (int i = n; i < 2 * n; i++) {
            ans[(i - n) * 2 + 1] = nums[i];
        }
        return ans;
    }
};
```
第一个循环将原数组的前半部分元素插入到新数组的偶数索引位置，第二个循环将原数组的后半部分元素插入到新数组的奇数索引位置。

#### 方法二：双指针
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> result;
        int i = 0; // 前半部分指针
        int j = n; // 后半部分指针
        while (i < n && j < 2 * n) {
            result.push_back(nums[i]);
            result.push_back(nums[j]);
            i++;
            j++;
        }
        return result;
    }
};
```
使用两个指针分别指向原数组的前半部分和后半部分。通过交替选择元素，将它们添加到新数组中。
时间复杂度：O(n)，其中 n 是数组的长度。我们需要遍历整个数组并将元素添加到结果数组中。

[官方题解](https://leetcode.com/problems/shuffle-the-array/editorial/)

![image](https://github.com/qifeibro/likou_note/assets/87322305/61a90829-323c-41ed-868d-0a255bebef78)

### Approach 1: Simple Iteration

#### Intuition
 
The elements of  x  should be placed at indices  `0, 2, 4, ...`. At  `nums[i]`  we have element  $x_{i + 1}$​, we should place it at index  2 * i  for all  $0 \le i \lt n$.

The elements of  y  should be placed at indices  `1, 3, 5, ...`. At  `nums[n + i]`  we have element  $y_{i + 1}$​, we should place it at index  2 * i + 1  for all  $0 \le i \lt n$. Notice that it is the same formula as the previous one but with a  `+1`, indicating that elements of  y  come after elements of  x.

![image](https://github.com/qifeibro/likou_note/assets/87322305/8443cbf5-d225-45a8-82fc-d5b566022dad)

One of the intuitive ways to solve this is to have an extra array  $\text{result}$  of size  2 * n, then iterate over  $\text{nums}$  and place each of its elements at the respective positions in  $\text{result}$.

#### Algorithm

1.  Build an array  `result`  of size  `2 * n`.
2.  Iterate over the  `nums`  array ranging from indices  `0`  to  `n - 1`:
    -   Store the element  $x_{i + 1}$​  , that is,  `nums[i]`  at index  `2 * i`,  
        and element  $y_{i + 1}$​  , that is,  `nums[i + n]`  at index  `2 * i + 1`  in  `result`.
3.  Return the  `result`  array.

#### Implementation

```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> result(2 * n);
        for (int i = 0; i < n; ++i) {
            result[2 * i] = nums[i];
            result[2 * i + 1] = nums[n + i];
        }
        return result;
    }
};
```
#### Complexity Analysis

Here,  2 * n  is the number of elements in the  `nums`  array.

-   Time complexity:  O(n).
    -   We iterate on  n  elements of the  `nums`  array, which takes us  O(n)  time.
    -   Initializing the  `result`  array will take  O(2n)  time.
    -   Thus, overall we take  O(n + 2n) = O(n)  time.
-   Space complexity:  O(1).
    -   We are not using any additional space other than the output array.

### Approach 2: In-place Filling

#### Intuition

The previous approach is optimal and sufficient for most interviews.  
But sometimes the interviewer might come up with a follow-up to perform the changes in-place in the input array without using an output array.

> This approach is much more difficult than the previous one and is included for completeness. Don't be discouraged(灰心) if you aren't able to come up with it yourself.

So, we can't store the numbers in some additional space. Additionally, rewriting a number will erase the previous value. Hence, here the interviewer would like to check our understanding of bit manipulation.

<details>
<summary>If you are not aware of bit manipulation first, let's get a brief idea about it and look at some basic bitwise operators(按位运算符).</summary> 
<br>
Bit manipulation is the act of manipulating bits, like changing bits of an integer.  
At the heart of bit manipulation are the bit-wise operators:

**NOT (~):**  Bitwise NOT is a unary operator that flips the bits of the number i.e., if the current bit is  0, it will change it to  1  and vice versa.  
```
N = 5 = 101 (in binary)
~N = ~(101) = 010 = 2 (in decimal)
```
**AND (&):** In bitwise AND if both bits in the compared position of the bit patterns are 1, the bit in the resulting bit pattern is 1, otherwise 0.
```
A = 5 = 101 (in binary) 
B = 1 = 001 (in binary) 
A & B = 101 & 001 = 001 = 1 (in decimal)
```
**OR ( | ):** Bitwise OR is also similar to bitwise AND. If both bits in the compared position of the bit patterns are 0, the bit in the resulting bit pattern is 0, otherwise 1.
```
A = 5 = 101 (in binary) 
B = 1 = 001 (in binary) 
A | B = 101 | 001 = 101 = 5 (in decimal)
```
**XOR (^):** In bitwise XOR if both bits are 0 or 1, the result will be 0, otherwise 1.
```
A = 5 = 101 (in binary) 
B = 1 = 001 (in binary) 
A ^ B = 101 ^ 001 = 100 = 4 (in decimal)
```
**Left Shift (<<):** Left shift operator is a binary operator which shifts some number of bits to the left and appends 0 at the end. One left shift is equivalent to multiplying the bit pattern with 2.
```
A = 1 = 001 (in binary) 
A << 1 = 001 << 1 = 010 = 2 (in decimal)
A << 2 = 001 << 2 = 100 = 4 (in decimal)

B = 5 = 00101 (in binary)
B << 1 = 00101 << 1 = 01010 = 10 (in decimal)
B << 2 = 00101 << 2 = 10100 = 20 (in decimal)
```
**Right Shift (>>):** Right shift operator is a binary operator which shifts some number of bits to the right and appends 0 at the left side. One right shift is equivalent to dividing the bit pattern with 2.
```
A = 4 = 100 (in binary) 
A >> 1 = 100 >> 1 = 010 = 2 (in decimal)
A >> 2 = 100 >> 2 = 001 = 1 (in decimal)
A >> 3 = 100 >> 3 = 000 = 0 (in decimal)

B = 5 = 00101 (in binary)
B >> 1 = 00101 >> 1 = 00010 = 2 (in decimal)
```
</details>

Now coming back to our problem, we can see that the maximum possible value of an element of the  nums  array is  10^3  which is  1111101000  in binary.  
Thus each element will take at most  10-bits in a  32-bit integer and the remaining bits are  0  and not used.

This suggests the idea that in the remaining empty unused bits we can store some extra information.  
One possible solution is storing two numbers together (the first number in the first ten bits and the second in the next ten bits) without using additional space.

![image](https://github.com/qifeibro/likou_note/assets/87322305/d95f0a7b-3091-4f7f-b605-ae9addd40bf4)

我们将把 nums 数组的前 n 个数字和后 n 个数字存储在一起。因此， $x_i$ 和 $y_i$ 将分别存储在第 i 个索引处。

然后，我们可以从索引 (n-1) 到索引 0 对存储的数字对进行迭代，并将它们放置在各自的位置上。<br>
我们选择这个方向（从右向左）是因为，即使右侧的元素被覆盖，我们也不会再次使用这些被覆盖的元素，因为当前索引（i）拥有的数字对始终小于或等于更新的单元格（i <= 2 * i 和 2 * i + 1）。<br>
因此，被覆盖的元素已经在之前放置在它们的正确位置上。

![image](https://github.com/qifeibro/likou_note/assets/87322305/ecb6a4bd-b74f-4a39-b1f4-eccfc9f965bc)

**将两个数字一起存储：**

a 是第一个数字，b 是第二个数字。

我们可以将 b 左移 10 位，并将其与 a 进行按位或操作。<br>
当我们将任何位与 0 进行按位或操作时，结果仍然是该位本身，而与 1 进行按位或操作的结果是 1。

$b_{new}$ 的前 10 位是 0。因此，当我们将其与 a 进行按位或操作时，结果的前 10 位将包含 a 的 10 位，而 a 的下一个 10 位是 0，因此结果的下一个 10 位将存储 b 的 10 位。<br>
因此，最终的结果包含了 a 和 b 的位。

![image](https://github.com/qifeibro/likou_note/assets/87322305/59a4aad4-af21-44eb-82cd-244dceb8312d)

**提取两个数字：**

result 是同时包含 a（第一个数字）和 b（第二个数字）的数字。

result 的前 10 位包含 a。因此，我们可以通过与 0000000000 1111111111 进行按位与操作来提取它（十进制表示为 1023）。<br>
当我们将某个位与 1 进行按位与操作时，结果仍然是该位本身；与 0 进行按位与操作的结果为 0。

result 的下一个 10 位包含 b，因此我们可以通过将其右移 10 位来提取它。

![image](https://github.com/qifeibro/likou_note/assets/87322305/92314a45-a097-4004-9ab7-3178bd716d72)

#### 算法：
1. 从索引 i = n 迭代遍历 nums 数组到 2 * n - 1：
    - 使用之前讨论过的位操作，将元素 $y_{i+1}$（即 nums[i]）与 $x_{i+1}$（即 nums[i-n]）存储在索引 (i - n) 处。
2. 从索引 n - 1 到 0 迭代，并在每个索引 i 处：
    - 使用位操作提取出 firstNumber 和 secondNumber，并将它们存储在 nums 数组的索引 2 * i 和 2 * i + 1 处。
3. 返回 nums 数组。

#### 实现：
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        // Store each y(i) with respective x(i).
        for (int i = n; i < 2 * n; ++i) {
            int secondNum = nums[i] << 10;
            nums[i - n] |= secondNum;
        }

        // '0000000000 1111111111' in decimal.
        int allOnes = pow(2, 10) - 1;

        // We will start putting all numbers from the end, 
        // as they are empty places.
        for (int i = n - 1; i >= 0; --i) {
            // Fetch both the numbers from the current index.
            int secondNum = nums[i] >> 10;
            int firstNum = nums[i] & allOnes;
            nums[2 * i + 1] = secondNum;
            nums[2 * i] = firstNum;
        }
        return nums;
    }
};
```
#### 复杂度分析：
这里，2 * n 是 nums 数组中元素的数量。

- 时间复杂度：O(n)。
    - 我们只对 nums 数组的 n 个元素进行两次迭代，所以时间复杂度为 O(n)。
- 空间复杂度：O(1)。
    - 我们没有使用额外的空间。

[liuyubobobo题解](https://leetcode.cn/problems/shuffle-the-array/solution/kong-jian-fu-za-du-wei-o1-de-liang-chong-jie-fa-by/)

#### 方法一：

因为题目限制了每一个元素 nums[i] 最大只有可能是 1000，这就意味着每一个元素只占据了 10 个 bit。（2^10 - 1 = 1023 > 1000）

而一个 int 有 32 个 bit，所以我们还可以使用剩下的 22 个 bit 做存储。实际上，每个 int，我们再借 10 个 bit 用就好了。

因此，在下面的代码中，每一个 nums[i] 的最低的十个 bit（0-9 位），我们用来存储原来 nums[i] 的数字；再往前的十个 bit（10-19 位），我们用来存储重新排列后正确的数字是什么。

在循环中，我们每次首先计算 nums[i] 对应的重新排列后的索引 j，之后，取 nums[i] 的低 10 位（nums[i] & 1023），即 nums[i] 的原始信息，把他放到 nums[j] 的高十位上。

最后，每个元素都取高 10 位的信息(e >> 10)，即是答案。

```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {

        for(int i = 0; i < 2 * n; i ++){
            int j = i < n ? 2 * i : 2 * (i - n) + 1; 
            nums[j] |= (nums[i] & 1023) << 10; // 1
        }
        for(int& e: nums) e >>= 10;
        return nums;
    }
};
```
1. 为什么需要 nums[i] & 1023，而不能直接用 nums[i] ?
因为处理到nums[n]以后的数的时候，这些数本来需要往前移动，但是在处理前面数的时候他们已经被处理过了，这时候他们内部的格式是[这里应该放的数，这里本来的数]， &一下后，nums[n]就恢复到了这里本来数

#### 方法二：使用负数标记已经是重新排列后的正确数字
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        int len = 2 * n;
        for (int i = 0; i < len; i++) {
            int j = i; // j 表示当前的 nums[i] 对应的索引，初始为 i
            while (nums[i] > 0) {
                j = j < n ? 2 * j : 2 * (j - n) + 1; // 得到 当前 nums[i] 对应的索引 应该放置的索引
                swap(nums[i], nums[j]); // 
                nums[j] = -nums[j];
            }
            nums[j] = -nums[j]; // 使用负号标记上，现在 j 位置存储的元素已经是正确的元素了
        }
        return nums;
    }
};
```
如果不能理解看下面代码, 两个代码逻辑是一样的:
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        int len = 2 * n;
        for (int i = 0; i < len; i++) {
            int j = i; // 用变量 j 始终存放 i 位置存放的元素的索引
            while (nums[i] > 0) {
                int next = (j < n) ? (2 * j) : (2 * (j - n) + 1); // 计算 i 位置存放的元素 应放在next位置
                swap(nums[i], nums[next]); // 交换后, 原本 i 位置的元素放在了正确的位置, 并把 next 位置的元素 放到了 i 位置
                nums[next] = -nums[next]; // 标记 next 位置已经存放了正确的元素
                j = next; // 更新 i 位置存放的元素的索引
            }
            nums[j] = -nums[j]; // 还原数组中的元素正数值
        }
        return nums;
    }
};
```
[宫水三叶题解](https://leetcode.cn/problems/shuffle-the-array/solution/by-ac_oier-3lck/)
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> ans(2 * n);
        for (int i = 0, j = n, k = 0; k < 2 * n; k++) {
            ans[k] = k % 2 == 0 ? nums[i++] : nums[j++];
        }
        return ans;
    }
};
```
1.  使用三个变量`i`、`j`和`k`来进行循环和索引操作。
    -   `i`用于追踪原数组中前半部分元素的索引，初始值为0。
    -   `j`用于追踪原数组中后半部分元素的索引，初始值为`n`。
    -   `k`用于追踪重排后数组`ans`的索引，初始值为0。
2.  进入循环，条件是`k < 2 * n`，即遍历`ans`数组的所有位置。
3.  在每次循环中，使用条件表达式`k % 2 == 0`来判断当前位置`k`的奇偶性。
    -   如果`k`是偶数，则将`ans[k]`赋值为`nums[i]`，并将`i`自增1，以获取下一个前半部分元素。
    -   如果`k`是奇数，则将`ans[k]`赋值为`nums[j]`，并将`j`自增1，以获取下一个后半部分元素。
