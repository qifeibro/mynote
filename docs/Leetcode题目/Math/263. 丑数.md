#### [263. 丑数](https://leetcode.cn/problems/ugly-number/)

难度简单

**丑数** 就是只包含质因数 `2`、`3`  和  `5` 的正整数。

给你一个整数  `n`  ，请你判断  `n`  是否为  **丑数**  。如果是，返回  `true`  ；否则，返回  `false`  。

**示例 1：**
```
输入：n = 6
输出：true
解释：6 = 2 × 3
```
**示例 2：**
```
输入：n = 1
输出：true
解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。
```
**示例 3：**
```
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
```
**提示：**

-   `-2^31  <= n <= 2^31  - 1`

#### 方法一：递归
```
class Solution {
public:
    bool isUgly(int n) {
        if (n <= 0) {
            return false;
        }
        if (n == 1) {
            return true;
        }

        if (n % 2 == 0) {
            return isUgly(n / 2);
        }
        if (n % 3 == 0) {
            return isUgly(n / 3);
        }
        if (n % 5 == 0) {
            return isUgly(n / 5);
        }

        return false;
    }
};
```
递归解法的时间复杂度是 O(log n)，其中 n 是输入的整数。
递归解法的空间复杂度主要取决于递归调用的深度，即递归栈的大小。

由于每次递归调用都会将 n 的值减小，且每个递归调用之间的数据不会共享，因此递归栈的最大深度为 log(n)。因此，递归解法的空间复杂度是 O(log n)。

需要注意的是，递归解法的实际空间使用可能会受到系统限制，当递归调用的深度超过系统限制时，可能会导致栈溢出。因此，在实际使用递归解法时，需要注意输入范围的限制，以避免栈溢出的问题。

#### 方法二：迭代
```cpp
class Solution {
public:
    bool isUgly(int n) {
        if (n <= 0) {
            return false;
        }
        while (n % 2 == 0) {
            n /= 2;
        }
        while (n % 3 == 0) {
            n /= 3;
        }
        while (n % 5 == 0) {
            n /= 5;
        }
        return n == 1;
    }
};
```

```cpp
class Solution {
public:
    bool isUgly(int n) {
        if (n < 1) {
            return false;
        }
        while (n != 1) {
            if (n % 5 == 0) {
                n /= 5;
            } else if (n % 3 == 0) {
                n /= 3;
            } else if (n % 2 == 0) {
                n /= 2;
            } else {
                return false;
            }
        }
        return n;
    }
};
```

```cpp
class Solution {
public:
    bool isUgly(int n) {
        if (n <= 0) return false;
        while (!(n % 3)) n /= 3;
        while (!(n % 5)) n /= 5;
        return (n & (n - 1)) == 0;
    }
};
```

[官方题解](https://leetcode.com/problems/ugly-number/editorial/)

#### Intuition

Let's follow the definition.

> _An  **ugly number**  is a positive integer whose prime factors are limited to 2, 3, and 5_.

<img width="557" alt="Screen Shot 2023-05-18 at 8 25 52 PM" src="https://github.com/qifeibro/likou_note/assets/87322305/d1926605-4b6d-4bfb-ba4d-3ecf9919167f">

An **ugly number** is a _positive integer_. As per constraints $-2^{31} \leq n \leq 2^{31} - 1$, we can have non-positive integers. Since a non-positive integer cannot be ugly, we can immediately `return false` if $n \leq 0$.

For  n > 0, we have to examine if the integer is an ugly number or not.  
As per the given definition, the only permitted prime factors for an ugly number are 2, 3, and 5. Thus, if we remove all 2's, 3's, and 5's from the prime factorization(质因数分解) of this integer, we can check if there is some other prime in the remaining factorization or not.

-   What we can do is check if the integer is divisible by(被整除) 2 or not. If yes, then we have obtained one prime factor as 2. Then, we have to find the prime factors of the integer obtained by dividing this integer by 2. We will keep dividing our integer by 2 when it is divisible by 2.
    
-   At this point, this integer is no longer divisible by 2. Thus, try dividing it with the next permitted factor, i. e. 3. Keep dividing the integer by 3 when it is divisible by 3.
    
-   At this point, this integer is no longer divisible by 2 or by 3. Thus, try dividing it with the next permitted factor, i. e. 5. Keep dividing the integer by 5 when it is divisible by 5.
    
-   Now, the integer is no longer divisible by 2, 3, or 5. If this integer is not equal to 1, we can deduce(推断) that there are other prime factors of this integer, apart from 2, 3, and 5. Hence, the number is not ugly. If the integer was 1, the number is ugly.

#### Algorithm

1.  If the given integer  `n`  is non-positive, we can  `return false`  since a non-positive integer cannot be ugly.
    
2.  Define a function  `keepDividingWhenDivisible`  which takes two arguments,  `dividend(被除数)`  and  `divisor(除数)`.
    
    This function will keep dividing the  `dividend`  by  `divisor`  when it is divisible by  `divisor`. An integer  `dividend`  is divisible by  `divisor`  if it gives the remainder as 0 when divided by  `divisor`. Many programming languages provide  `mod`  (`%`) binary operator for computing the remainder. This function then returns the modified  `dividend`.
    
3.  Keep dividing  `n`  by 2 when it is divisible by 2 by calling  `keepDividingWhenDivisible(n, 2)`.
    
    > **Note:**  We can use bit manipulation to check if an integer is divisible by 2. We can check the Least Significant Bit (LSB)(最低有效位) in the binary representation of the integer. If  **LSB is 1**, it means the  **number is odd**, and hence not divisible by 2. If  **LSB is 0**, it means the  **number is even**, and hence divisible by 2. We can check if LSB is 1 or not by  n \& 1.
    > 
    > And to divide the integer by 2, we can simply right-shift the integer by 1-bit. This can be done by  $n = n \gg 1$.
    
4.  At this point, the integer is no longer divisible by 2. Now, keep dividing  `n`  by 3 when it is divisible by 3 by calling  `keepDividingWhenDivisible(n, 3)`.
    
5.  Now, the integer is neither divisible by 2, nor by 3. Now, keep dividing  `n`  by 5 when it is divisible by 5 by calling  `keepDividingWhenDivisible(n, 5)`.
    
6.  At this point, the integer is not divisible by any of 2, 3, or 5. Thus, as per(按照) the definition of Ugly Number, our integer, if it was ugly must have been reduced to 1. Thus, if  `n`  is 1, return  `true`, otherwise  `false`.

**Note:**  Since steps 3, 4, and 5 are similar, we can use a loop to perform these steps.

#### Implementation
```cpp
class Solution {
public:
    bool isUgly(int n) {
        // A non-positive integer cannot be ugly
        if (n <= 0) {
            return false;
        }

        // Factorize by dividing with permitted factors.
        for (auto factor : {2, 3, 5}) {
            n = keepDividingWhenDivisible(n, factor);
        }

        // Check if the integer is reduced to 1 or not.
        return n == 1;
    }

    // Keep dividing dividend by divisor when division is possible.
    int keepDividingWhenDivisible(int dividend, int divisor) {
        while (dividend % divisor == 0) {
            dividend /= divisor;
        }
        return dividend;
    }
};
```
```cpp
class Solution {
public:
    bool isUgly(int n) {
        if (n <= 0) {
            return false;
        }
        for (int factor : {2, 3, 5}) {
            while (n % factor == 0) {
                n /= factor;
            }
        }
        return n == 1;      
    }
};
```

**Implementation Note**

For unifying the approach for all three permitted factors, bit manipulation is not used in implementation because we cannot use  O(1)  bit manipulation to divide by 3 or 5.

#### Complexity Analysis

Let  N  be the  **magnitude(大小)**  of the input integer.

-   Time complexity:  $O(\log (N))$.
    
    We are dividing the integer by 2, 3, and 5 and terminating when it is not divisible by any of them.
    
    > **When dividing an integer  x  by  y, there can be at most  $O( \log_y(x) )$  divisions.**
    > 当将一个整数 x 除以 y 时，最多可能进行 $O( \log_y(x) )$ 次除法运算。
    > Assume we perform the division by  2  for  K  times. Then, we can say that the number  N  is at least  2^K, which means  $2^K \leq N$. Therefore  $K \leq \log_2 N$.
    
    Thus, there can be at most  $\log_2(N)$  divisions by 2,  $log_3(N)$  divisions by 3 and  $\log_5(N)$  divisions by 5. Thus, total number of divisions will be at most  $\log_2(N) + \log_3(N) + \log_5(N)$, which is  $O(\log (N))$.
    
-   Space complexity:  O(1).
    
    There are a handful of variables in the code, and all of them use constant space, hence, space complexity is constant

Similar Questions

[Happy Number](https://leetcode.com/problems/happy-number/) Easy

[Count Primes](https://leetcode.com/problems/count-primes/) Medium

[Ugly Number II](https://leetcode.com/problems/ugly-number-ii/) Medium

----------

Related Topics

[Math](https://leetcode.com/tag/math/)
