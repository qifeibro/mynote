#### [258. 各位相加](https://leetcode.cn/problems/add-digits/)

难度简单

给定一个非负整数  `num`，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。

**示例 1:**
```
输入: num =  38
输出: 2 
解释: 各位相加的过程为：
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
由于 2 是一位数，所以返回 2。
```
**示例 2:**
```
输入: num = 0
输出: 0
```
**提示：**

-   `0 <= num <= 2^31 - 1`

**进阶：** 你可以不使用循环或者递归，在  `O(1)`  时间复杂度内解决这个问题吗？

#### Overview
这道题的本质是计算自然数 num 的数根。

数根又称数字根（[Digital root](https://en.wikipedia.org/wiki/Digital_root)），是自然数的一种性质，每个自然数都有一个数根。对于给定的自然数，反复将各个位上的数字相加，直到结果为一位数，则该一位数即为原自然数的数根。

计算数根的最直观的方法是模拟计算各位相加的过程，直到剩下的数字是一位数。利用自然数的性质，则能在 O(1) 的时间内计算数根。

#### Approach 1: 模拟，迭代
```cpp
class Solution {
public:
    int addDigits(int num) {
        int tmp;
        while (num > 9) {
            tmp = 0;
            while (num > 0) {
                tmp += num % 10;
                num /= 10;
            }
            num = tmp;
        }
        return num;
    }
};
```

```cpp
class Solution {
public:
    int addDigits(int num) {
        int digitalRoot = 0;
        while (num > 0) {
            digitalRoot += num % 10;
            num = num / 10;
            
            if (num == 0 && digitalRoot > 9) {
                num = digitalRoot;
                digitalRoot = 0;  
            }    
        }     
        return digitalRoot;
    }
};
```

```cpp
class Solution {
public:
    int addDigits(int num) {
        while (num > 9) {
            num = num / 10 + num % 10;
        }
        return num;
    }
};
```

#### Approach 2: Mathematical: Digital Root

**Formula for the Digital Root**
There is a known formula to compute a digital root in a decimal numeral system(十进制数字系统)

$dr_{10}(n) = 0, \qquad \text{if } n = 0$<br>
$dr_{10}(n) = 9, \qquad \text{if } n = 9 k$<br>
$dr_{10}(n) = n \mod 9, \qquad \text{if } n \ne 9 k$

How to derive it? Probably, you already know the following proof from school, where it was used for a divisibility by 9: "The original number is divisible by 9 if and only if the sum of its digits is divisible by 9". Let's revise it briefly.<br>
如何推导出这个公式？可能您已经知道以下证明，它用于判断能否被9整除：“原数能被9整除，当且仅当它的各位数字之和能被9整除”。让我们简要回顾一下。

The input number could be presented in a standard way, where $d_0, d_1, .. d_k$ are digits of n:

$n = d_0 + d_1 * 10^1 + d_2 * 10^2 + ... + d_k * 10^k$

One could expand each power of ten(十的幂), using the following:

10 = 9 * 1 + 1<br>
100 = 99 + 1 = 9 * 11 + 1<br>
1000 = 999 + 1 = 9 * 111 + 1<br>
...<br>

```math
\begin{flalign*}
  10^k &= 1\underbrace{00\dots 0}_{k \text{ times}} \\
       &= \underbrace{99\dots 9}_{k \text{ times}} + 1 \\
       &= 9 * \underbrace{11\dots 1}_{k \text{ times}} + 1 &
\end{flalign*}
```

<img width="684" alt="Screen Shot 2023-05-13 at 12 34 38 AM" src="https://github.com/qifeibro/likou_note/assets/87322305/ba609fcc-8f83-45a9-89ff-b07acc36ef48">

**Implementation**

The straightforward implementation is
```cpp
class Solution {
public:
    int addDigits(int num) {
        if (num == 0) return 0;
        if (num % 9 == 0) return 9;
        return num % 9;
    }
};
```
though two last cases could be merged into one

$dr_{10}(n) = 0, \qquad \text{if } n = 0$

$dr_{10}(n) = 1 + (n - 1) \mod 9, \qquad \text{if } n \ne 0$

```cpp
class Solution {
public:
    int addDigits(int num) {
        return num == 0 ? 0 : 1 + (num - 1) % 9;
    }
};
```

```cpp
class Solution {
public:
    int addDigits(int num) {
        return (num - 1) % 9 + 1;
    }
};
```
**Complexity Analysis**

-   Time Complexity:  $\mathcal{O}(1)$.
    
-   Space Complexity:  O(1).

#### Approach 3: 递归
```cpp
class Solution {
public:
    int addDigits(int num) {
        // 如果 num 是一位数，直接返回
        if (num < 10) {
            return num;
        }
        int sum = 0;
        // 将 num 的每一位相加
        while (num) {
            sum += num % 10;
            num /= 10;
        }
        // 递归调用 addDigits，直到得到一位数为止
        return addDigits(sum);
    }
};

```

[官方题解](https://leetcode.com/problems/add-digits/editorial/)

Similar Questions

[Happy Number](https://leetcode.com/problems/happy-number/) Easy

[Sum of Digits in the Minimum Number](https://leetcode.com/problems/sum-of-digits-in-the-minimum-number/) Easy

[Sum of Digits of String After Convert](https://leetcode.com/problems/sum-of-digits-of-string-after-convert/) Easy

[Minimum Sum of Four Digit Number After Splitting Digits](https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/) Easy

[Calculate Digit Sum of a String](https://leetcode.com/problems/calculate-digit-sum-of-a-string/) Easy

[Difference Between Element Sum and Digit Sum of an Array](https://leetcode.com/problems/difference-between-element-sum-and-digit-sum-of-an-array/) Easy

[Alternating Digit Sum](https://leetcode.com/problems/alternating-digit-sum/) Easy

----------

Related Topics

[Math](https://leetcode.com/tag/math/) [Simulation](https://leetcode.com/tag/simulation/) [Number Theory](https://leetcode.com/tag/number-theory/)
