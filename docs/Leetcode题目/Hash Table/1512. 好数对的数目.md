#### [1512. 好数对的数目](https://leetcode.cn/problems/number-of-good-pairs/)

难度简单

给你一个整数数组  `nums`  。

如果一组数字  `(i,j)`  满足  `nums[i]`  ==  `nums[j]`  且  `i`  <  `j`  ，就可以认为这是一组  **好数对**  。

返回好数对的数目。

**示例 1：**
```
输入：nums = [1,2,3,1,1,3]
输出：4
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始
```
**示例 2：**
```
输入：nums = [1,1,1,1]
输出：6
解释：数组中的每组数字都是好数对
```
**示例 3：**
```
输入：nums = [1,2,3]
输出：0
```
**提示：**

-   `1 <= nums.length <= 100`
-   `1 <= nums[i] <= 100`

#### 方法一：暴力统计
```cpp
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int n = nums.size();
        int count = 0;
        for (int i = 0; i < n - 1; i++)
            for (int j = i + 1; j < n; j++)
                if (nums[i] == nums[j]) count++;
        return count;
    }
};
```
**复杂度分析**

- 时间复杂度：O(n^2)。
- 空间复杂度：O(1)。

#### 方法二：组合计数
```cpp
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> m;
        for (int num: nums) {
            m[num]++;
        }
        for (const auto &[k, v]: m) { // 遍历哈希表中的每个键值对
            ans += v * (v - 1) / 2;
        }
        return ans;
    }
};
```
在`const auto &[k, v] : m`中，const表示键值对是只读的，&表示引用，[k, v]是对哈希表m中的每个键值对进行解构，将键值对中的键和值分别赋值给k和v。这样就可以方便地遍历哈希表m中的每个键值对，并且可以避免键值对的复制，提高代码的效率。
![image](https://github.com/qifeibro/likou_note/assets/87322305/8a3677e1-0e1f-4929-92ed-3071b98d0b26)
The formula N choose 2 = N * (N-1) / 2 is derived from the combinatorial formula for combinations:

N choose 2 = N! / (2! * (N-2)!)

We can simplify this formula as follows:

N! / (2! * (N-2)!) = N * (N-1) * (N-2)! / (2 * 1 * (N-2)!)

Canceling out the (N-2)! term and simplifying, we get:

N * (N-1) / 2

Therefore, N choose 2 can be calculated as N * (N-1) / 2. This formula is often used in situations where we need to calculate the number of ways to choose 2 items from a group of N items, where order doesn't matter (such as counting the number of pairs in an array or the number of ways to form a committee of 2 people from a group of N people).

**复杂度分析**

- 时间复杂度：O(*n*)。
- 空间复杂度：O(*n*)，即哈希表使用到的辅助空间的空间代价。

```cpp
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int hash[101], sum = 0;
        memset(hash, 0, sizeof(hash));
        for (int i = 0; i < nums.size(); ++i) {
            ++hash[nums[i]];
        }
        for (int i = 1; i <= 100; ++i) {
            int x = hash[i];
            sum += x * (x-1) / 2; // 1
        }
        return sum;
    }
};
```
这段代码使用了一个大小为101的数组来作为哈希表，对于数组中的每个数字，统计其出现的次数。然后遍历哈希表中的每个数字，计算该数字可以组成的好数对数量，并将其累加到sum变量中。最后返回sum即为数组中所有的好数对数量。

具体地，对于一个数字i，假设它在数组中出现了x次，则它可以和数组中除了它自己之外的x-1个数字组成好数对，因此好数对的数量为x*(x-1)/2。这里除以2是因为每个好数对被计算了两次，例如如果数字i和数字j都出现了x次，那么(i, j)和(j, i)会被分别计算一次。因此，最后统计的好数对数量需要除以2。

也可以这样理解: 对于数字1有 x 个，对第一个‘1’来说，后面有 x-1 个‘1’，对第二个‘1’来说，后面有 x-2 个‘1’，........ ,对于倒数第二个‘1’来说，后面只有1个‘1’，所以总数是 = x-1 + x-2 + x-3 + ....... +3 + 2 + 1 =x*(x-1)/2

或者理解为 n choose 2

这段代码和上面那段代码的思路是相同的，都是使用哈希表来统计每个数字出现的次数，并计算好数对的数量。它们的时间复杂度都是O(n)，其中n是数组的长度。但是这段代码使用了数组来作为哈希表，而上面的代码使用了unordered_map。一般来说，unordered_map比数组更灵活，可以应对更复杂的情况。但是在这道题目中，由于数组中的数字的取值范围比较小，只有1到100，因此使用数组作为哈希表更加简单和高效。

因此，这段代码比上面那段代码的效率更高。但是需要注意的是，由于使用了一个大小为101的数组，因此空间复杂度也相应地增加了。

#### 方法三：哈希表
```c
int numIdenticalPairs(int* nums, int numsSize){
    int ans = 0;
    int hash[101];
    memset(hash, 0, sizeof(hash));
    for (int i = 0; i < numsSize; ++i) {
        ans += hash[nums[i]]; // 统计当前数字之前已经出现过的次数，加到答案中
        ++hash[nums[i]];
    }
    return ans;
}
```

```cpp
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        unordered_map<int, int> m;
        int ans = 0;
        for (int num : nums) {
            ans += m[num];
            m[num]++;
        }
        return ans;
    }
};
```

```cpp
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        unordered_map<int, int> m;
        int ans = 0;
        for (int num : nums)
            ans += m[num]++;
        return ans;
    }
};
```
`m[num]++`会将`num`作为键在`m`中查找对应的值，如果键不存在，则会插入一个新的键值对（键为`num`，值为0），然后对值进行自增操作。这样做的效果是，如果有重复的元素出现，每次遇到相同的元素时，都会将其计数加1。

```cpp
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        return accumulate(nums.begin(), nums.end(), 0, [m = unordered_map<int, int> {}] (auto ans, auto num) mutable {
            return ans + m[num]++;
        });
    }
};
```
使用了 lambda表达式

Similar Questions

[Number of Pairs of Interchangeable Rectangles](https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/) Medium

[Substrings That Begin and End With the Same Letter](https://leetcode.com/problems/substrings-that-begin-and-end-with-the-same-letter/) Medium

----------

Related Topics

[Array](https://leetcode.com/tag/array/) [Hash Table](https://leetcode.com/tag/hash-table/) [Math](https://leetcode.com/tag/math/) [Counting](https://leetcode.com/tag/counting/)

在C++11之后，引入了auto和range-based for循环，方便我们对容器进行遍历。

auto关键字可以自动推导出变量的类型，可以避免手动指定变量类型的繁琐过程。例如：
```cpp
int x = 1;
auto y = x; // y的类型自动推导为int
```
而range-based for循环是一种遍历容器元素的方式，可以简化遍历过程。例如：
```cpp
vector<int> v = {1, 2, 3};
for (int x : v) { // 遍历v中的每个元素，将其赋值给变量x
    cout << x << endl;
}
```

C++语言支持使用`memset()`函数来对数组进行初始化。`memset()`函数的作用是将一段内存空间全部设置为某个指定的值，通常用于对数组、结构体等数据结构进行初始化。函数原型为：
```cpp
void *memset(void *s, int c, size_t n);
```
其中`s`表示要进行初始化的内存空间的起始地址，`c`表示要设置的值，`n`表示要设置的内存空间的大小。在上面的代码中，`memset(hash, 0, sizeof(hash))`的作用是将`hash`数组的所有元素都设置为0。
