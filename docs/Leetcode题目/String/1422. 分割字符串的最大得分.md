#### [1422. 分割字符串的最大得分](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/)

难度简单

给你一个由若干 0 和 1 组成的字符串  `s`  ，请你计算并返回将该字符串分割成两个  **非空**  子字符串（即 **左**  子字符串和  **右**  子字符串）所能获得的最大得分。

「分割字符串的得分」为  **左**  子字符串中  **0**  的数量加上  **右**  子字符串中  **1**  的数量。

**示例 1：**
```
输入：s = "011101"
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3
```
**示例 2：**
```
输入：s = "00111"
输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5
```
**示例 3：**
```
输入：s = "1111"
输出：3
```
**提示：**

-   `2 <= s.length <= 500`
-   字符串  `s`  仅由字符  `'0'`  和  `'1'`  组成。

[力扣官方题解](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/solution/fen-ge-zi-fu-chuan-de-zui-da-de-fen-by-l-7u5p/)
#### 方法一：枚举每个分割点
```cpp
class Solution {
public:
    int maxScore(string s) {
        int ans = 0;
        int n = s.length();
        for (int i = 1; i < n; i++) {
            int count0 = 0; // 1
            int count1 = 0;
            for (int j = 0; j < i; j++) {
                if (s[j] == '0') {
                    count0++;
                }
            }
            for (int j = i; j < n; j++) {
                if (s[j] == '1') {
                    count1++;
                }
            }
            ans = count0 + count1 > ans ? count0 + count1 : ans; // 2
        }
        return ans;
    }
};
```
1. count0 和 count1 可以合并成一个变量
2. 可以用 max() 函数 代替 条件表达式

优化如下：
```cpp
class Solution {
public:
    int maxScore(string s) {
        int ans = 0;
        int n = s.length();
        for (int i = 1; i < n; i++) {
            int score = 0;
            for (int j = 0; j < i; j++) {
                if (s[j] == '0') {
                    score++;
                }
            }
            for (int j = i; j < n; j++) {
                if (s[j] == '1') {
                    score++;
                }
            }
            ans = max(ans, score);
        }
        return ans;
    }
};
```
以下是代码的解释：

1.  将`ans`初始化为0。这个变量将存储迄今为止找到的最大得分。
2.  获取输入字符串`s`的长度，并将其存储在变量`n`中。
3.  从`i = 1`到`i < n`开始循环。这个循环遍历所有可能的字符串分割位置。
4.  在循环内，将`score`变量初始化为0。这个变量将跟踪当前分割的得分。
5.  从`j = 0`到`j < i`开始另一个循环。这个循环遍历分割位置之前的字符。
6.  检查`s[j]`是否等于`'0'`。如果是，则将`score`增加1，因为`'0'`代表一个得分点。
7.  从`j = i`到`j < n`开始一个新的循环。这个循环遍历分割位置之后的字符。
8.  检查`s[j]`是否等于`'1'`。如果是，则将`score`增加1，因为`'1'`代表一个得分点。
9.  在嵌套循环之后，将`score`与当前最大得分`ans`进行比较。如果`score`大于`ans`，则更新`ans`。
10.  一旦评估了所有可能的分割位置，返回最大得分`ans`。

总体而言，该代码计算每个可能的分割位置的得分，并跟踪找到的最大得分。该解决方案的时间复杂度为O(n^2)，其中n是输入字符串`s`的长度。

#### 方法二：两次遍历
可以换一个角度思考，如果分割点从左到右移动一位，则位于原分割点处的字符从右子字符串中移除并添加到左子字符串中，根据该字符的值更新分割字符串的得分。

当 1≤i<n 时，分割点 i 将字符串 s 分割成两个非空子字符串，左子字符串的下标范围是 [0,i−1]，右子字符串的下标范围是 [i,n−1]。对于 1≤i<n−1，当分割点从 i 移动到 i+1 时，位于下标 i 处的字符 s[i] 从右子字符串中移除并添加到左子字符串中，分割字符串的得分变化如下：

如果 s[i]=0，则左子字符串的得分加 1，右子字符串的得分不变，因此分割字符串的得分加 1；

如果 s[i]=1，则左子字符串的得分不变，右子字符串的得分减 1，因此分割字符串的得分减 1。
```cpp
class Solution {
public:
    int maxScore(string s) {
        int maxScore = 0;
        int zerosCount = 0; // 1
        int onesCount = 0;

        // Count the number of ones in the original string
        for (char c : s) {
            if (c == '1') {
                onesCount++;
            }
        }

        // Iterate through all possible split positions
        for (int i = 0; i < s.length() - 1; i++) {
            // Update the counts based on the current split position
            if (s[i] == '0') {
                zerosCount++;
            } else {
                onesCount--;
            }

            // Calculate the score for the current split position
            int score = zerosCount + onesCount;
            // Update the maximum score if necessary
            maxScore = max(maxScore, score);
        }

        return maxScore;
    }
};
```
1. 将 zerosCount 和 onesCount 合并，如下: <br>
```cpp
class Solution {
public:
    int maxScore(string s) {
        int maxScore = 0;
        int score = 0;

        // Count the number of ones in the original string
        for (char c : s) {
            if (c == '1') {
                score++;
            }
        }

        // Iterate through all possible split positions
        for (int i = 0; i < s.length() - 1; i++) { // 1
            // Update the counts based on the current split position
            if (s[i] == '0') {
                score++;
            } else {
                score--;
            }

            // Update the maximum score if necessary
            maxScore = max(maxScore, score);
        }

        return maxScore;
    }
};
```
1. 注意，迭代范围为s.length() - 1，因为根据问题的约束，右子字符串至少需要一个字符。

[宫水三叶题解](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/solution/by-ac_oier-3wua/)
#### 方法一：前缀和
构建前缀和数组来记录每个前缀中 1 的个数，复杂度为 O(n)，枚举每个分割点，搭配前缀和数组计算左串中 0 的数量和右串中 1 的数量，取所有得分的最大值即是答案。
```cpp
class Solution {
public:
    int maxScore(string s) {
        int n = s.length();
        int ans = 0;
        vector<int> prefix(n);
        
        prefix[0] = s[0] - '0';
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + (s[i] - '0');
        }

        for (int i = 0; i < n - 1; i++) {
            int a = i + 1 - prefix[i]; // i + 1 表示左子串的元素总个数, prefix[i] 表示 [0,i] 也就是左子串中 '1' 的数量
            int b = prefix[n - 1] - prefix[i];
            ans = max(ans, a + b);
        }
        return ans;
    }
};
```
另一种前缀和模板
```cpp
class Solution {
public:
    int maxScore(string s) {
        int n = s.length();
        int ans = 0;
        vector<int> prefix(n + 1);
        
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + (s[i] - '0');
        }

        for (int i = 1; i < n; i++) {
            int a = i - prefix[i]; // i 表示左子串的元素总个数, prefix[i] 表示 [0, i - 1] 也就是左子串中 '1' 的数量
            int b = prefix[n] - prefix[i];
            ans = max(ans, a + b);
        }
        return ans;
    }
};
```

#### 方法二：模拟
```cpp
class Solution {
public:
    int maxScore(string s) {
        int n = s.length();
        int maxScore = 0;
        int score = 0;
        for (int i = 0; i < n; i++) {
            score += s[i] - '0';
        }
        for (int i = 0; i < n - 1; i++) {
            score += s[i] == '0' ? 1 : -1;
            maxScore = max(maxScore, score);
        }
        return maxScore;
    }
};
```
更进一步，利用 s 中有只有 0 和 1，我们可以边遍历 s 边计算得分（而无须预处理前缀和数组）。

当 s[i]=0，说明有一个 0 从右串中移到了左串，并且 0 在右串中不得分，在左串中得分，因此总得分加一；而当 s[i]=1，说明有一个 1 从右串中移到了左串，而 1 在右串中得分，在左串中不得分，因此总得分减一。在所有得分中取最大值即是答案。

Related Topics

[String](https://leetcode.com/tag/string/)
