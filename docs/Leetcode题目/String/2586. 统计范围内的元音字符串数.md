#### [2586. 统计范围内的元音字符串数](https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/)

难度简单

给你一个下标从  **0**  开始的字符串数组  `words`  和两个整数：`left`  和  `right`  。

如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个  **元音字符串**  ，其中元音字母是  `'a'`、`'e'`、`'i'`、`'o'`、`'u'`  。

返回  `words[i]`  是元音字符串的数目，其中  `i`  在闭区间  `[left, right]`  内。

**示例 1：**
```
输入：words = ["are","amy","u"], left = 0, right = 2
输出：2
解释：
- "are" 是一个元音字符串，因为它以 'a' 开头并以 'e' 结尾。
- "amy" 不是元音字符串，因为它没有以元音字母结尾。
- "u" 是一个元音字符串，因为它以 'u' 开头并以 'u' 结尾。
在上述范围中的元音字符串数目为 2 。
```
**示例 2：**
```
输入：words = ["hey","aeo","mu","ooo","artro"], left = 1, right = 4
输出：3
解释：
- "aeo" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。
- "mu" 不是元音字符串，因为它没有以元音字母开头。
- "ooo" 是一个元音字符串，因为它以 'o' 开头并以 'o' 结尾。
- "artro" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。
在上述范围中的元音字符串数目为 3 。
```
**提示：**

-   `1 <= words.length <= 1000`
-   `1 <= words[i].length <= 10`
-   `words[i]`  仅由小写英文字母组成
-   `0 <= left <= right < words.length`

```cpp
class Solution {
public:
    int vowelStrings(vector<string>& words, int left, int right) {
        int count = 0;
        for (int i = left; i <= right; i++) {
            if (isVowel(words[i][0]) && isVowel(words[i][words[i].size() - 1])) {
                count++;
            }
        }
        return count;        
    }
private:
    bool isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }
};
```
Time complexity: O(n), where n is the number of words in the array.

#### 方法二：无序集合(unordered_set)
```cpp
class Solution {
public:
    int vowelStrings(vector<string>& words, int left, int right) {
        // 创建一个无序集合，存储元音字母
        unordered_set<char> s{'a','e','i','o','u'};
        int cnt = 0; // 计数器，记录元音字符串的数量
        for(int i = left; i <= right; i++) {
            const auto& str = words[i]; // 获取当前字符串
            // 判断当前字符串的第一个字符和最后一个字符是否都在无序集合中
            if(s.count(str[0]) && s.count(str[str.size()-1]))
                cnt++; // 如果是，则计数器加一
        }
        return cnt; // 返回计数器的值作为结果
    }
};
```
使用一个无序集合（unordered_set）来存储元音字母。然后遍历指定范围内的每个字符串，对于每个字符串，判断其第一个字符和最后一个字符是否都在无序集合中，如果是，则计数器加一。

[0x3f题解](https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/solution/mei-ju-by-endlesscheng-p5ju/)
```python3
class Solution:
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(s[0] in "aeiou" and s[-1] in "aeiou" for s in words[left:right+1])
```
在 Python 中，如果生成器表达式是作为函数参数传递的唯一参数，那么括号是可以省略的。例如，可以在调用 `tuple` 函数时省略括号：
```python3
tuple_example = tuple(x for x in range(5))
```
在 Python 3 中，许多内置类型和数据结构都是可迭代的（iterable）。以下是一些常见的可迭代对象的示例：

1.  序列类型（Sequences）：列表（list）、元组（tuple）、字符串（string）
2.  集合类型（Sets）：集合（set）、冻结集合（frozenset）
3.  映射类型（Mappings）：字典（dictionary）
4.  文件对象（File objects）
5.  生成器（Generators）：包括生成器函数和生成器表达式

需要注意的是，生成器（generators）是可迭代的一种特殊类型，它们是使用生成器函数或生成器表达式创建的。生成器通过在迭代过程中动态生成值，而不是一次性将所有值存储在内存中。

然而，需要注意的是生成器表达式只能迭代一次，一旦迭代完成，就需要重新创建生成器表达式才能再次进行迭代。

#### 扩展
`unordered_set` 类是 C++ 标准库中的一个容器类
在 C++ 中，使用 `unordered_set` 类需要包含 `<unordered_set>` 头文件。你可以通过添加 `#include <unordered_set>` 来导入该头文件。

##### 创建无序集合
```cpp
unordered_set<int> mySet;
```

在 C++ 中，可以使用大括号初始化列表或在构造函数中传递两个迭代器作为参数来初始化无序集合。下面是两种常见的初始化无序集合的方法：

###### 方法一：使用大括号初始化列表
```cpp
unordered_set<int> mySet = {1, 2, 3, 4, 5};
// 在 C++ 中，对于大括号初始化列表，可以省略等号，直接将元素放在大括号内。
unordered_set<int> mySet{1, 2, 3, 4, 5};
```
###### 方法二：使用迭代器范围初始化
```cpp
vector<int> vec = {1, 2, 3, 4, 5};
unordered_set<int> mySet(vec.begin(), vec.end());
```

##### 向集合中添加元素
```cpp
mySet.insert(10);
mySet.insert(20);
mySet.insert(30);
```

##### 使用范围遍历（range-based for loop）打印集合中的元素
```cpp
for (const auto& element : mySet) {
    cout << element << " ";
}
```
`const auto& element` 是范围遍历（range-based for loop）的一部分。它用于声明一个引用变量 `element`，用于迭代访问集合中的元素。

具体解释如下：

-   `auto`：`auto` 是 C++11 中的关键字，用于自动推导变量的类型。在范围遍历中，`auto` 会自动推导为集合中元素的类型。
-   `const`：`const` 修饰符表示该变量是一个只读变量，即在范围遍历中，无法通过该变量修改集合中的元素。
-   `&`：`&` 表示引用类型，通过引用访问集合中的元素，可以避免元素的复制。

因此，`const auto& element` 表示一个只读引用，用于逐个访问集合中的元素。在范围遍历过程中，变量 `element` 会依次引用集合中的每个元素，以供后续代码使用。

##### 常用的 `unordered_set` 类的成员函数：

1.  `insert()`: 插入元素到集合中。
2.  `erase()`: 从集合中移除指定的元素。
3.  `clear()`: 清空集合，移除所有元素。
4.  `find()`: 查找集合中是否存在指定的元素。
5.  `count()`: 统计集合中与指定元素相等的元素的数量。
6.  `size()`: 返回集合中元素的数量。
7.  `empty()`: 检查集合是否为空。
8.  `begin()`, `end()`: 返回指向集合起始位置和结束位置的迭代器。
9.  `unordered_set::iterator`: 迭代器类型，用于遍历集合中的元素。

###### count
注意，由于 unordered_set 是一个集合容器，其中不允许存在重复元素，因此 count() 函数返回的结果只能是 0 或 1，表示元素存在或不存在。
