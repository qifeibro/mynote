#### [709. 转换成小写字母](https://leetcode.cn/problems/to-lower-case/)

难度简单

给你一个字符串  `s`  ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。

**示例 1：**
```
输入：s = "Hello"
输出："hello"
```
**示例 2：**
```
输入：s = "here"
输出："here"
```
**示例 3：**
```
输入：s = "LOVELY"
输出："lovely"
```
**提示：**

-   `1 <= s.length <= 100`
-   `s`  由 ASCII 字符集中的可打印字符组成

#### 方法一：使用语言 API
```cpp
class Solution {
public:
    string toLowerCase(string s) {
        for (char& ch: s) {
            ch = tolower(ch);
        }
        return s;
    }
};
```
使用了字符引用 `char& ch`，即对 `s` 字符串中的每个字符都使用引用的方式进行修改。通过 `tolower` 函数将字符转换为小写字母，然后直接修改原字符串中的字符。
如果将字符引用 `char& ch`改成字符副本 `char ch`，即对 `s` 字符串中的每个字符都使用副本的方式进行修改。同样通过 `tolower` 函数将字符转换为小写字母，但是修改的是副本 `ch`，并没有修改原字符串中的字符。因此最终返回的是未修改过的原字符串 `s`。

```cpp
class Solution {
public:
    string toLowerCase(string s) {
        for (auto it = s.begin(); it != s.end(); ++it) {
            if (isupper(*it)) {
                *it = tolower(*it);
            }
        }
        return s;
    }
};
```

#### 方法二
```cpp
class Solution {
public:
    string toLowerCase(string s) {
        for (char& c : s) {
            if (c >= 'A' && c <= 'Z') {
                c |= 32;
            }
        }
        return s;
    }
};
```

```cpp
class Solution {
public:
    string toLowerCase(string s) {
        for (auto &ch : s)
            if (ch >= 65 && ch <= 90)
                ch |= 32;
        return s;
    }
};
```
字母全转小写: ch|=32 (大写 |= 32 就相当于+32，小写 |= 32 不变)<br>
字母全转大写: ch&=-33 (大写 &= -33 不变，小写 &= -33 相当于 -32) (原理是32的补码(原码取反+1)再-1)<br>
字母大小写对换(大写变小写，小写变大): ch^=32 (大写 ^= 32 相当于 +32，小写 ^= 32 相当于 -32)<br>

为什么可以这样运算？
先查看一下ASCII表，只看字母相关部分，如图：
![image](https://github.com/qifeibro/likou_note/assets/87322305/9c82bab5-8470-44ee-b9b7-2e8eaa28185d)
把字母当成 8 个bit 位来看，我把大小字母对应的后 4 位圈出来了。

大家有没有发现 A-a B-b ... Z-z 26个字母之间的大小写的后 4 位是完全一样的！！！<br>
（重要知识点1：对应大小字母的 后4位二进制是一样的）

再来看一下头 4位。对应大小字母之间就第 3位 的 bit 值不一样！！！
（重要知识点2：对应大小字母的前4位中，只有第3位bit值不一样）
把不一样的bit位单独取出来，其它位补 0，也就是 0b0010 0000，对应的十进制数就是 32 ！！！

#### 方法三
```cpp
class Solution {
public:
    string toLowerCase(string s) {
        string ans;
        for (int i = 0; i < s.length(); i++) {
            char c;
            if (s[i] >= 65 && s[i] <= 90)
                c = s[i] + 32;
            else
                c = s[i];
            ans.push_back(c); // 使用 push_back 方法将字符插入到 ans 字符串的末尾
        }
        return ans;
    }
};
```

```cpp
class Solution {
public:
    string toLowerCase(string s) {
        for (int i = 0; i < s.length(); i++) {
            if (s[i] >= 65 && s[i] <= 90)
                s[i] = s[i] + 32;
        }
        return s;
    }
};
```

```cpp
class Solution {
public:
    string toLowerCase(string s) {
        string ans;
        ans.resize(s.length());  // 为 ans 字符串分配和 s 字符串一样的长度
        for (int i = 0; i < s.length(); i++) {
            char c;
            if (s[i] >= 65 && s[i] <= 90)
                c = s[i] + 32;
            else
                c = s[i];
            ans[i] = c;  // 使用 [] 运算符将字符赋值给 ans 字符串的每个位置
        }
        return ans;
    }
};
```
要使用 `[]` 运算符为字符串赋值，需要先确保该字符串有足够的空间。可以使用 `resize` 方法为字符串分配足够的空间，然后使用 `[]` 运算符赋值。

Similar Questions

[Capitalize the Title](https://leetcode.com/problems/capitalize-the-title/) Easy

----------

Related Topics

[String](https://leetcode.com/tag/string/)

#### 位运算符

![image.png](https://pic.leetcode-cn.com/1615691379-TPWDJp-image.png)

在 C++ 中，`string str;` 和 `string str = "";` 两者的效果是一样的，都是定义了一个空字符串。

`string str;` 定义了一个默认构造函数的 `std::string` 对象，该对象初始化为空字符串，即长度为 0，不含任何字符。

`string str = "";` 定义了一个默认构造函数的 `std::string` 对象，并将一个空字符串赋值给该对象，使其也成为一个空字符串，即长度为 0，不含任何字符。

在实际使用中，推荐使用 `string str;` 来定义一个空字符串，因为它更加简洁，而且效果一样。而 `string str = "";` 可以看作是对默认构造函数和赋值操作的一种冗余写法，没有实际的必要。

#### 遍历字符串
在 C++ 中，可以使用字符串的下标运算符 `[]` 或迭代器来遍历字符串。下面是两种遍历字符串的方法：

1.  使用下标运算符 `[]`：
```cpp
std::string str = "Hello, world!";
for (int i = 0; i < str.length(); i++) {
    char c = str[i];
    // 对每个字符 c 进行处理
    std::cout << c << " ";
}
```
在这里，使用 `str.length()` 获取字符串的长度，然后通过下标运算符 `[]` 遍历字符串中的每个字符。

2.  使用迭代器：
```cpp
std::string str = "Hello, world!";
for (auto it = str.begin(); it != str.end(); ++it) {
    char c = *it;
    // 对每个字符 c 进行处理
    std::cout << c << " ";
}
```
在这里，使用 `str.begin()` 获取指向字符串第一个字符的迭代器，使用 `str.end()` 获取指向字符串最后一个字符的下一个位置的迭代器，然后使用迭代器遍历字符串中的每个字符。

注意，在遍历字符串时，如果只是需要读取字符串中的字符，可以使用 `const` 修饰字符串类型，以避免不必要的复制。例如：
```cpp
const std::string str = "Hello, world!";
for (auto it = str.begin(); it != str.end(); ++it) {
    char c = *it;
    // 对每个字符 c 进行处理
    std::cout << c << " ";
}
```
下标运算符 `[]` 和迭代器都可以用于遍历 C++ 中的容器，包括字符串。

下标运算符 `[]` 是 C++ 中一个方便的、直观的遍历容器元素的方法。使用下标运算符可以直接访问容器中的元素，不需要像迭代器那样需要使用解引用符号 `*`，语法比较简单明了。

迭代器则是一个更加通用的容器遍历方式。使用迭代器可以遍历容器中的元素，对于一些容器，如链表，只能通过迭代器来访问元素。迭代器的语法可能不太直观，但迭代器提供了更加灵活的操作，例如可以在遍历容器时删除或插入元素。

下面是两种遍历方式的优缺点：

下标运算符 `[]` 的优点：

-   语法简单，直观易懂；
-   可以直接访问容器中的元素。

下标运算符 `[]` 的缺点：

-   可能越界，如果下标越界可能导致程序崩溃；
-   对于一些容器，如链表，不能使用下标运算符访问元素。

迭代器的优点：

-   可以遍历任何类型的容器；
-   可以在遍历容器时进行插入、删除等操作。

迭代器的缺点：

-   语法较为繁琐，不够直观；
-   可能越界，如果越界可能导致程序崩溃。

#### 将字符插入字符串
在 C++ 中，可以使用字符串的 `push_back` 方法将字符插入字符串末尾，也可以使用字符串的 `insert` 方法将字符插入到字符串中的任意位置。

下面是两种方法的示例：

1.  使用 `push_back` 方法将字符插入字符串末尾：
```cpp
std::string str = "Hello, world!";
str.push_back('a');
```
在这里，使用 `push_back` 方法将字符 `'a'` 插入到字符串 `str` 的末尾。

2.  使用 `insert` 方法将字符插入到字符串中的任意位置：
```cpp
std::string str = "Hello, world!";
str.insert(5, "a");
```
在这里，使用 `insert` 方法将字符 `'a'` 插入到字符串 `str` 中的第 5 个位置，即字符串 `str` 的第 6 个字符位置（字符串下标从 0 开始计数）。

注意，`insert` 方法的第一个参数是插入位置的下标，第二个参数是插入的字符串或字符。

如果要插入的是一个字符串，可以使用另一个重载的 `insert` 方法：
```cpp
std::string str = "Hello, world!";
str.insert(5, "xyz");
```
在这里，使用 insert 方法将字符串 "xyz" 插入到字符串 str 中的第 5 个位置，即字符串 str 的第 6 个字符位置。
