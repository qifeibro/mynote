#### [949. 给定数字能组成的最大时间](https://leetcode.cn/problems/largest-time-for-given-digits/)

难度中等

给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。

24 小时格式为  `"HH:MM"`  ，其中  `HH`  在  `00`  到  `23`  之间，`MM`  在  `00`  到  `59`  之间。最小的 24 小时制时间是 `00:00`  ，而最大的是 `23:59`  。从 00:00 （午夜）开始算起，过得越久，时间越大。

以长度为 5 的字符串，按  `"HH:MM"`  格式返回答案。如果不能确定有效时间，则返回空字符串。

**示例 1：**
```
输入：arr = [1,2,3,4]
输出："23:41"
解释：有效的 24 小时制时间是 "12:34"，"12:43"，"13:24"，"13:42"，"14:23"，"14:32"，"21:34"，"21:43"，"23:14" 和 "23:41" 。这些时间中，"23:41" 是最大时间。
```
**示例 2：**
```
输入：arr = [5,5,5,5]
输出：""
解释：不存在有效的 24 小时制时间，因为 "55:55" 无效。
```
**示例 3：**
```
输入：arr = [0,0,0,0]
输出："00:00"
```
**示例 4：**
```
输入：arr = [0,0,1,0]
输出："10:00"
```
**提示：**

-   `arr.length == 4`
-   `0 <= arr[i] <= 9`

```cpp
class Solution {
public:
    string largestTimeFromDigits(vector<int>& arr) {
        int m = -1; // 用于记录最大的时间值
        string ans = ""; // 用于记录最大时间对应的字符串
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (j == i) {
                    continue;
                }
                for (int k = 0; k < 4; k++) {
                    if (k == i || k == j) {
                        continue;
                    }
                    for (int l = 0; l < 4; l++) {
                        if (l == i || l == j || l == k) {
                            continue;
                        }
                        if (10 * arr[i] + arr[j] <= 23 && 10 * arr[k] + arr[l] <= 59) {
                            if ((10 * arr[i] + arr[j]) * 60 + 10 * arr[k] + arr[l] > m) {
                                m = (10 * arr[i] + arr[j]) * 60 + 10 * arr[k] + arr[l];
                                ans = to_string(arr[i]) + to_string(arr[j]) + ":" + to_string(arr[k]) + to_string(arr[l]);
                            }
                        }
                    }
                }
            }
        }
        return ans;
    }
};
```
通过四重嵌套的循环遍历所有可能的时间组合，其中`arr[i]`、`arr[j]`、`arr[k]`、`arr[l]`分别代表小时和分钟的十位和个位数字。

在每次循环中，通过检查小时和分钟的值是否在合法范围内（小时小于等于23，分钟小于等于59），来确定是否是一个有效的时间。如果是有效的时间，并且当前时间值大于之前记录的最大时间值`m`，则更新`m`和对应的时间字符串`ans`。

最后，返回记录最大时间的字符串`ans`。

```cpp
class Solution {
public:
    string largestTimeFromDigits(vector<int>& arr) {
        string maxTime = "";
        backtrack(arr, 0, maxTime);
        return maxTime;
    }

    void backtrack(vector<int>& arr, int start, string& maxTime) {
        if (start == 4) {
            // Check if current combination forms a valid time
            string time = toTime(arr);
            if (isValidTime(time) && time > maxTime) {
                maxTime = time;
            }
            return;
        }

        for (int i = start; i < 4; i++) {
            swap(arr[start], arr[i]);
            backtrack(arr, start + 1, maxTime);
            swap(arr[start], arr[i]);
        }
    }

    string toTime(vector<int>& arr) {
        string time = "";
        time += to_string(arr[0]);
        time += to_string(arr[1]);
        time += ":";
        time += to_string(arr[2]);
        time += to_string(arr[3]);
        return time;
    }

    bool isValidTime(string time) {
        int hour = stoi(time.substr(0, 2));
        int minute = stoi(time.substr(3, 2));
        return hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59;
    }
};
```
回溯法，通过不断尝试不同的组合来生成可能的时间。它会遍历所有可能的组合，并通过剪枝操作来排除无效的组合。时间复杂度取决于生成所有可能组合的数量，即O(4!)，即O(24)。

[leetcode editorial](https://leetcode.com/problems/largest-time-for-given-digits/editorial/)
#### Approach 1: Enumerate the Permutations

**Intuition**
> iterate through all possible permutations of the given 4 digits, and for each permutation, we check if we could build a time out of it in the 24H format (_i.e._  `HH:MM`).

There are two conditions that we should meet, in order to construct a valid time format:

-   `HH < 24`: The first two digits,  _i.e._  the hour, should be less than 24.
    
-   `MM < 60`: The last two digits,  _i.e._  the minute, should be less than 60.

**Algorithm**

-   The algorithm can be implemented in a single loop over all the possible permutations for the given 4 digits.
    
-   At each iteration, we check if we could build a valid time based on the conditions we presented before.
    
-   Meanwhile, we use a variable (_i.e._`max_time`) to keep track of the maximum valid time that we've seen during the iteration.
