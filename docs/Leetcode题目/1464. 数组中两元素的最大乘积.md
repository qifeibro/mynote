#### [1464. 数组中两元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/)

难度简单

给你一个整数数组  `nums`，请你选择数组的两个不同下标  `i`  和  `j`，使  `(nums[i]-1)*(nums[j]-1)`  取得最大值。

请你计算并返回该式的最大值。

**示例 1：**
```
输入：nums = [3,4,5,2]
输出：12 
解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 
```
**示例 2：**
```
输入：nums = [1,5,4,5]
输出：16
解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。
```
**示例 3：**
```
输入：nums = [3,7]
输出：12
```
**提示：**

-   `2 <= nums.length <= 500`
-   `1 <= nums[i] <= 10^3`

Related Topics

[Array](https://leetcode.com/tag/array/) [Sorting](https://leetcode.com/tag/sorting/) [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)

##### Two Pass
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int idx = 0;
        int max = 0;
        int max2 = 0;
        for (int i = 0; i < n; i++) {
            if (max < nums[i]) {
                max = nums[i];
                idx = i;
            }
        }
        for (int i = 0; i < n; i++) {
            if (i == idx) {
                continue;
            }
            if (max2 < nums[i]) {
                max2 = nums[i];
            }
        }
        return (max - 1) * (max2 - 1);
    }
};
```
时间复杂度为 O(n)，空间复杂度为 O(1)

##### Sorting
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        return (nums[n - 1] - 1) * (nums[n - 2] - 1);
    }
};
```
时间复杂度为 O(nlogn)，空间复杂度为 O(1)。它使用了 std::sort 函数来对整个数组进行排序，排序的时间复杂度为 O(nlogn)。<br>

`vector<int>& nums`表示一个名为 `nums` 的向量（vector）变量，它的元素类型为 `int`。
`&` 符号表示这是一个引用类型参数，通过引用传递参数可以避免在函数调用时进行复制，从而提高程序的效率。
引用类型参数可以直接修改传入的变量，因此函数内部对 `nums` 数组进行排序的操作，会直接改变传入的 `nums` 数组的元素顺序。<br>
`vector<int>& nums`，表示一个名为 `nums` 的引用类型参数，引用了一个存储整数类型元素的动态数组（vector），
其中 `vector` 是 C++ 标准库提供的容器类型，`int` 是 `vector` 中元素的类型。
使用引用类型参数可以使得函数直接操作原始的向量，而不是进行传值，避免复制带来的性能开销和空间浪费。
在函数内部，可以通过 `nums` 直接访问并修改原始向量中的元素。<br>
`nums.begin()` 和 `nums.end()` 分别表示 `nums` 数组的起始位置和结束位置<br>
`sort(nums.begin(), nums.end())` 表示对 `nums` 数组的元素从小到大进行排序。

##### One Pass
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int max = 0, max2 = 0;
        for (int num : nums)
            if (num > max) {
                max2 = max;
                max = num;
            }
            else if (num > max2)
                max2 = num;
        return (max - 1) * (max2 - 1);
    }
};
```
时间复杂度为 O(n)，空间复杂度为 O(1)

##### Heap (Priority Queue)
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        priority_queue<int> pq;

        // 将数组元素插入到堆中
        for (int i = 0; i < nums.size(); i++) {
            pq.push(nums[i]);
        }

        int max1 = pq.top(); // 堆中最大元素
        pq.pop();
        int max2 = pq.top(); // 堆中次大元素

        // 返回两个最大元素-1的乘积
        return (max1 - 1) * (max2 - 1);
    }
};
```
时间复杂度：将n个元素插入到堆中的时间复杂度为O(n log n)，因为每次插入一个元素的时间复杂度是O(log n)。弹出最大和次大元素的时间复杂度均为O(log n)，因为堆的大小为n。所以总的时间复杂度为O(n log n)。

空间复杂度：堆的大小为n，所以空间复杂度为O(n)。

**为什么从堆中弹出最大元素不是O(1)，而是O(log n) ？**

从堆中弹出最大元素的时间复杂度是O(log n)，因为堆的结构保证了最大元素总是在堆顶（根节点），但是在弹出最大元素之后，堆结构需要重新调整，以保证剩余元素仍然满足堆的性质，即父节点比子节点大（对于大根堆）。调整堆结构的过程称为堆化，这个过程的时间复杂度是O(log n)。

具体来说，当从堆中弹出最大元素后，可以将最后一个元素移动到堆顶，然后比较它与它的子节点的大小，如果它比子节点小，则将它与子节点交换位置。重复此过程，直到它成为了所有子节点的父节点，或者已经没有子节点。这个过程的时间复杂度是O(log n)，因为每次比较和交换都只会影响到堆的一部分，而且堆的高度是log n。

因此，从堆中弹出最大元素的时间复杂度是O(log n)，而不是O(1)。

**为什么 堆的高度是log n ？**

堆是一种完全二叉树，其中每个节点的值都大于或等于（或小于或等于，取决于是大根堆还是小根堆）其子节点的值。因此，堆的高度是log n，其中n是堆中元素的数量。

假设堆中有n个元素。堆的高度是由堆中的路径长度定义的，路径长度是从根节点到叶节点的边数。在一个完全二叉树中，每个深度都有最多2^h个节点，其中h是深度（从0开始）。因此，深度为k的节点可以包含的最多的节点数是2^k。

考虑在最坏的情况下，即堆中的所有元素都在一条最长的路径上。在这种情况下，路径的长度是堆的高度，它可以被定义为log2n（以2为底数）。因此，堆的高度是log n。因为堆的高度是log n，所以插入和删除操作的时间复杂度是O(log n)。
