#### [231. 2 的幂](https://leetcode.cn/problems/power-of-two/)

难度简单

给你一个整数  `n`，请你判断该整数是否是 2 的幂次方。如果是，返回  `true`  ；否则，返回  `false`  。

如果存在一个整数  `x`  使得 `n == 2x`  ，则认为  `n`  是 2 的幂次方。

**示例 1：**
```
输入：n = 1
输出：true
解释：20 = 1
```
**示例 2：**
```
输入：n = 16
输出：true
解释：24 = 16
```
**示例 3：**
```
输入：n = 3
输出：false
```
**示例 4：**
```
输入：n = 4
输出：true
```
**示例 5：**
```
输入：n = 5
输出：false
```
**提示：**

-   `-2^31  <= n <= 2^31  - 1`

**进阶：** 你能够不使用循环/递归解决此问题吗？

```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        for (long i = 1; i <= n; i *= 2) 
            if (i == n) return true;
        return false;
    }
};
```
当将`long`改为`int`时，`i`会在每次迭代中乘以2，如果`n`的值很大，迭代的次数可能非常多。在某些情况下，迭代次数可能超过`int`的最大值，导致整数溢出，产生错误的结果。

而将`long`改为`unsigned`时，当输入的 n 为负数时，循环会无限进行，原因是因为无符号整数类型(unsigned)在进行乘法运算时，溢出会导致结果变为0，而不是负数。在每次循环中，变量i会不断乘以2，当i的值溢出为0后，它将不再增长，但循环条件`i <= n`仍然满足，因此循环会无限进行下去。这会导致代码陷入无限循环的状态。

在C++中，`int`类型的范围通常是-2^31到2^31-1（32位系统）或者-2^63到2^63-1（64位系统）

2^31 - 1 = 2147483647

```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;  // 对负数进行额外的检查
        for (unsigned i = 1; i <= n; i *= 2)
            if (i == n) return true;
        return false;
    }
};
```

```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) {
            return false;
        }
        unsigned ans = 1;
        // 当 ans 为 int 类型时，2147483648 相当于 -2147483647;
        while(1) {
            if (ans == n) {
                return true;
            } else if (ans > n) {
                break;
            }
            ans *= 2;
        }
        return false;
    }
};
```

![image](https://github.com/qifeibro/likou_note/assets/87322305/2c4523cf-496e-4a8f-a661-c5133c9d57bf)

```c
bool isPowerOfTwo(int n){
    if (n == 0) {
        return false;
    }

    while (n % 2 == 0) {
        n = n / 2;
    }
    if (n == 1) {
        return true;
    } else {
        return false;
    }
}
```

![image](https://github.com/qifeibro/likou_note/assets/87322305/e3c9532b-2589-419b-9488-f5209461767a)

```c
bool isPowerOfTwo(int n){
    return n > 0 && (n & (n - 1)) == 0; // ==优先级高于&高于&&
}
```

[优秀题解](https://leetcode.com/problems/power-of-two/solutions/1638707/python-c-java-detailly-explain-why-n-n-1-works-1-line-100-faster-easy/?orderBy=most_votes)

Similar Questions

[Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/) Easy

[Power of Three](https://leetcode.com/problems/power-of-three/) Easy

[Power of Four](https://leetcode.com/problems/power-of-four/) Easy

----------

Related Topics

[Math](https://leetcode.com/tag/math/) [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/) [Recursion](https://leetcode.com/tag/recursion/)
