#### [2235. 两整数相加](https://leetcode.cn/problems/add-two-integers/)

难度简单

给你两个整数 `num1`  和  `num2`，返回这两个整数的和。

**示例 1：**
```
输入：num1 = 12, num2 = 5
输出：17
解释：num1 是 12，num2 是 5 ，它们的和是 12 + 5 = 17 ，因此返回 17 。
```
**示例 2：**
```
输入：num1 = -10, num2 = 4
输出：-6
解释：num1 + num2 = -6 ，因此返回 -6 。
```
**提示：**

-   `-100 <= num1, num2 <= 100`

```cpp
class Solution {
public:
    int sum(int num1, int num2) {
        while (num1) {
            int carry = (num1 & num2) << 1; // 当 num1 和 num2 都为负数时报错
            num2 = num1 ^ num2;
            num1 = carry;
        }
        return num2;
    }
};
```

在C++中，左移运算符（<<）不能左移负数的位，因为左移操作是将二进制数按位向左移动指定的位数，并在右侧插入零。当左移的位数为负数时，行为是未定义的，因此程序的行为是不可预测的。

当涉及到左移运算符（<<）时，可以使用无符号整数类型来避免左移负数位的错误。因此，我们可以将输入的两个整数转换为无符号整数类型进行计算，然后将结果再转回有符号整数类型。具体的代码如下所示：
```cpp
class Solution {
public:
    int sum(int num1, int num2) {
        unsigned int u_num1 = static_cast<unsigned int>(num1); // 将num1转换为无符号整数
        unsigned int u_num2 = static_cast<unsigned int>(num2); // 将num2转换为无符号整数
        while (u_num1) {
            unsigned int carry = (u_num1 & u_num2) << 1; // 左移的操作数是无符号整数
            u_num2 = u_num1 ^ u_num2;
            u_num1 = carry;
        }
        return static_cast<int>(u_num2); // 将结果转换为有符号整数类型
    }
};
// 2 + 3
// 0b10
// 0b11

// carry 0b100
// num2 = 0b001
// num1 = carry = 0b100
// carry = 0
// num2 = 0b101 = 5
// num1 = carry = 0
```
这里使用了静态转换（static_cast）将有符号整数转换为无符号整数，并将左移操作的结果存储为无符号整数。最后，将结果转换回有符号整数类型并返回。

或者如下：
```cpp
class Solution {
public:
    int sum(int num1, int num2) {
        while (num1) {
            int carry = (unsigned)(num1 & num2) << 1;
            num2 = num1 ^ num2;
            num1 = carry;
        }
        return num2;
    }
};
```
时间复杂度为 $O(\log n)$，其中 $n$ 是两个整数中的较大值的位数。这是因为每次循环都会将进位部分向左移动一位，所以最多只需要进行 $\log_2 n$ 次循环即可完成计算。

为什么是 $\log_2 n$，而不是 $\log_{10} n$ ？

因为这个算法是基于二进制位运算的，所以其时间复杂度应该与二进制位数相关，而不是十进制位数。

在这个算法中，每次循环都会将进位部分向左移动一位，这相当于将二进制数乘以 $2$。因此，在进行 $k$ 次循环后，进位部分的值会变为原来的 $2^k$ 倍。如果两个整数中较大的那个有 $n$ 位二进制数，则最多需要进行 $\log_2 n$ 次循环，即 $2^{\log_2 n} = n$。因此，时间复杂度是 $O(\log_2 n)$，而不是 $O(\log_{10} n)$。

#### 知识点
<< 运算符（左移运算符）的优先级高于 & 运算符（按位与运算符）
