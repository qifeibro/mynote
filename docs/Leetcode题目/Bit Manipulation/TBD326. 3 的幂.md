#### [326. 3 的幂](https://leetcode.cn/problems/power-of-three/)

难度简单

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回  `true`  ；否则，返回  `false`  。

整数  `n`  是 3 的幂次方需满足：存在整数  `x`  使得  `n == 3x`

**示例 1：**
```
输入：n = 27
输出：true
```
**示例 2：**
```
输入：n = 0
输出：false
```
**示例 3：**
```
输入：n = 9
输出：true
```
**示例 4：**
```
输入：n = 45
输出：false
```
**提示：**

-   `-2^31  <= n <= 2^31  - 1`

**进阶：** 你能不使用循环或者递归来完成本题吗？

#### 知识点:
1. 
- -2^31 = -2147483648  
- 2^31 -1 = 2147483647

2. 对于有符号整数，最高位通常用于表示正负号，而其他位用于表示数值。在 32 位有符号整数中，最高位是符号位，即 1 表示负数，0 表示非负数。因此，-1 被表示为二进制数 32 位全为 1 的补码形式，即 1111 1111 1111 1111 1111 1111 1111 1111。<br>
无符号整数没有符号位，因此所有的位都用于表示数值。在 32 位无符号整数中，所有位都为 1，即 1111 1111 1111 1111 1111 1111 1111 1111，它表示的数值是最大值 4294967295。<br>
可以说，-1 和 4294967295 是在不同整数表示方法下所表示的同一个数。

3. 在C++中，当`unsigned` 类型和 `int` 类型的数值进行比较时，C++会进行隐式的类型转换。根据C++的整数提升规则，如果两个操作数具有不同的类型，其中一个是有符号整数类型，而另一个是无符号整数类型，那么有符号整数将会被转换为无符号整数。

#### 迭代
```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n <= 0) {
            return false;
        }
        for (unsigned i = 1; i <= n; i *= 3) {
            if (i == n) {
                return true;
            }
        }
        return false;
    }
};
```
时间复杂度为O(logn)，其中n是给定的整数。

在代码中，for循环的迭代次数取决于i的增长情况。初始值为1，每次循环将i乘以3，直到i大于n或者相等于n为止。因此，循环次数是log以3为底n的对数。

因此，代码的时间复杂度为O(logn)。

##### 疑点 如过在 for 循环 前面不把负数先排除的话， 当 n 为 负数时为什么会出现无限循环？
当输入 n 为 -1 时，在 for 循环的条件里进行 i <= n 判断时，此时 n 相当于 4294967295，i 很快就会从 1 增长到 3486784401, 此时依然满足循环条件，但是在执行完 i *= 3 之后，i 应该变成 10460353203，但是超出了 unsigned 的最大范围，将 10460353203 % 4294967296 可得 1870418611，于是 i 变成 1870418611 。在将 1870418611 * 3 = 5611255833，又超出了 unsigned 的最大范围(4294967295)，再将 5611255833 % 4294967296 可得 1316288537。至于为什么是 模 4294967296 而不是 模 4294967295，因为从 0 - 4294967295 共 4294967296 个数。相当于一个环，超出了这个最大范围，又会从下一圈开始，所以变成了无限循环。

```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        for (long i = 1; i <= n; i *= 3) {
            if (i == n) {
                return true;
            }
        }
        return false;
    }
};
```

```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n == 0) return n;
        while (n % 3 == 0) {
            n /= 3;
        }
        return n == 1;
    }
};
```
时间复杂度是O(log₃n)

空间复杂度是O(1)

#### 递归
```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n <= 0) {
            return false;
        } else if (n == 1) {
            return true;
        } else {
            return n % 3 == 0 && isPowerOfThree(n / 3);
        }
    }
};
```
时间复杂度是O(log₃n)

空间复杂度是O(log₃n)

[官方题解](https://leetcode.com/problems/power-of-three/editorial/)
#### Approach 1: Loop Iteration
One simple way of finding out if a number `n` is a power of a number `b` is to keep dividing `n` by `b` as long as the remainder is **0**. This is because we can write
$$n = b^x$$
$$n = b \times b \times ... \times b$$
Hence it should be possible to divide `n` by `b`  `x` times, every time with a remainder of **0** and the end result to be **1**.
```java
public class Solution {
    public boolean isPowerOfThree(int n) {
        if (n < 1) {
            return false;
        }

        while (n % 3 == 0) {
            n /= 3;
        }

        return n == 1;
    }
}
```
Notice that we need a guard to check that  `n != 0`, otherwise the while loop will never finish. For negative numbers, the algorithm does not make sense, so we will include this guard as well.

**Complexity Analysis**
-   Time complexity :  $O(\log_b(n))$. In our case that is  $O(\log_3n)$. The number of divisions is given by that logarithm.
    
-   Space complexity :  O(1). We are not using any additional memory.

#### Approach 2: Base Conversion(进制转换)

In Base 10, all powers of 10 start with the digit  **1**  and then are followed only by  **0**  (e.g. 10, 100, 1000). This is true for other bases and their respective powers. For instance in  _base 2_, the representations of  $10_2$​,  $100_2$  and  $1000_2$  are  $2_{10}$​,  $4_{10}$​  and  $8_{10}$​  respectively. Therefore if we convert our number to base 3 and the representation is of the form 100...0, then the number is a power of 3.

**Proof**

Given the base 3 representation of a number as the array  `s`, with the least significant digit on index 0, the formula for converting from base  **3**  to base  **10**  is:
$$\sum_{i=0}^{len(s)-1} s[i]∗3^i$$

Therefore, having just one digit of  **1**  and everything else  **0**  means the number is a power of 3.

**Implementation**

All we need to do is convert[^1] the number to  _base 3_  and check if it is written as a leading  **1**  followed by all  **0**.

A couple of built-in Java functions will help us along the way.
```java
String baseChange = Integer.toString(number, base);
```
The code above converts `number` into base `base` and returns the result as a `String`. For example, `Integer.toString(5, 2) == "101"` and `Integer.toString(5, 3) == "12"`.
将一个数转换为指定进制的字符串表示，可以使用Java中的`Integer.toString(number, base)`函数。其中，`number`是要转换的数值，`base`是目标进制。这个函数将返回表示该数值在指定进制下的字符串表示形式。
```java
boolean matches = myString.matches("123");
```
The code above checks if a certain **Regular Expression**  [^2] pattern exists inside a string. For instance the above will return true if the substring "123" exists inside the string `myString`.
```java
boolean powerOfThree = baseChange.matches("^10*$")
```
We will use the regular expression above for checking if the string starts with **1**  `^1`, is followed by zero or more **0**s `0*` and contains nothing else `＄`.
```java
public class Solution {
    public boolean isPowerOfThree(int n) {
        return Integer.toString(n, 3).matches("^10*$");
    }
}
```
**Complexity Analysis**

-   Time complexity :  $O(\log_3n)$.
    
    Assumptions:
    
    -   `Integer.toString()`  - Base conversion is generally implemented as a repeated division. The complexity of should be similar to our Approach 1:  $O(\log_3n)$.
    -   `String.matches()`  - Method iterates over the entire string. The number of digits in the base 3 representation of  `n`  is  $O(\log_3n)$.
-   Space complexity :  $O(\log_3n)$.
    
    We are using two additional variables,
    
    -   The string of the base 3 representation of the number (size  $\log_3n$)
    -   The string of the regular expression (constant size)

用C++实现如下：

```cpp
class Solution {
public:
    string intToBaseString(int number, int base) {
        string digits = "0123456789ABCDEF"; // 可用于基数<=16的数字字符
        string result;

        if (number == 0) {
            return "0";
        }

        while (number > 0) {
            int digit = number % base;
            result = digits[digit] + result;
            number /= base;
        }

        return result;
    }
    bool isPowerOfThree(int n) {
        string str = intToBaseString(n, 3);
        string pattern = "^10*$";
        return regex_match(str, regex(pattern));
    }
};
```
#### Approach 3: Mathematics

We can use mathematics as follows

$n = 3^i$

$i = \log_3n$

$i = \frac{log_bn}{log_b3}$

`n` is a power of three if and only if `i` is an integer. In Java, we check if a number is an integer by taking the decimal part (using `% 1`) and checking if it is 0.
```java
public class Solution {
    public boolean isPowerOfThree(int n) {
        return (Math.log10(n) / Math.log10(3)) % 1 == 0;
    }
}
```
**Common pitfalls(常见陷阱)**

This solution is problematic because we start using  `double`s, which means we are subject to precision errors. This means, we should never use  `==`  when comparing  `double`s. That is because the result of  `Math.log10(n) / Math.log10(3)`  could be  `5.0000001`  or  `4.9999999`. This effect can be observed by using the function  `Math.log()`  instead of  `Math.log10()`.

In order to fix that, we need to compare the result against an  `epsilon`.
```java
public class Solution {
    public boolean isPowerOfThree(int n) {
        double epsilon = 1e-10;  // 极小的误差
        return (Math.log(n) / Math.log(3) + epsilon) % 1 <= 2 * epsilon;
    }
}
```

**Complexity Analysis**

-   Time complexity :  Unknown  The expensive operation here is  `Math.log`, which upper bounds the time complexity of our algorithm. The implementation is dependent on the language we are using and the compiler  [^3]
    
-   Space complexity :  O(1). We are not using any additional memory. The  `epsilon`  variable can be inlined.

用C++实现如下：
```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        double epsilon = 1e-10;  // 极小的误差
        return fmod(log(n) / log(3) + epsilon, 1) <= 2 * epsilon;
    }
};
```
在C++中，使用`fmod()`函数而不是直接使用`%`运算符的原因是因为`%`运算符在处理浮点数时会引发错误。

`%`运算符是用于整数的取模运算，它返回两个操作数相除的余数。然而，它不适用于浮点数，因为浮点数的取模运算不仅涉及余数的计算，还涉及舍入和精度问题。

对于浮点数的精确取模运算，可以使用`fmod()`函数来实现。`fmod(x, y)`函数返回`x`除以`y`的余数，并确保结果具有与被除数相同的符号。这使得`fmod()`函数适用于处理浮点数的取模运算，包括在浮点数之间进行精确的比较和判断。

在给定的代码中，使用`fmod()`函数来计算`Math.log(n) / Math.log(3) + epsilon`除以1的余数，并将结果与误差（epsilon）进行比较，以确定一个数是否是3的幂。这样可以避免由于浮点数精度误差而导致的错误判断。

#### Approach 4: Integer Limitations

An important piece of information can be deduced from the function signature
```java
public boolean isPowerOfThree(int n)
```
In particular, `n` is of type `int`. In Java, this means it is a 4 byte, signed integer [ref]. The maximum value of this data type is **2147483647**. Three ways of calculating this value are
-   [Google](http://stackoverflow.com/questions/15004944/max-value-of-integer)
-   `System.out.println(Integer.MAX_VALUE);`
-   MaxInt =  $\frac{ 2^{32} }{2} - 1$  since we use 32 bits to represent the number, half of the range is used for negative numbers and 0 is part of the positive numbers

Knowing the limitation of n, we can now deduce that the maximum value of n that is also a power of three is 1162261467. We calculate this as:

$3^ {\lfloor {log_3​MaxInt} \rfloor} = 3^ {\lfloor {19.56} \rfloor} = 3^{19} = 1162261467$

Therefore, the possible values of `n` where we should return `true` are $3^0$, $3^1$ ... $3^{19}$. Since 3 is a prime number, the only divisors of $3^{19}$ are $3^0$, $3^1$ ... $3^{19}$, therefore all we need to do is divide $3^{19}$ by `n`. A remainder of **0** means `n` is a divisor of $3^{19}$ and therefore a power of three.

```java
public class Solution {
    public boolean isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
}
```
**Complexity Analysis**

-   Time complexity :  O(1). We are only doing one operation.
    
-   Space complexity :  O(1). We are not using any additional memory.

#### Performance Measurements

Single runs of the function make it is hard to accurately measure the difference of the two solutions. On LeetCode, on the  _Accepted Solutions Runtime Distribution_  page, all solutions being between  `15 ms`  and  `20 ms`. For completeness, we have proposed the following benchmark to see how the two solutions differ.

**Java Benchmark Code(Java基准测试代码)**
```java
public static void main(String[] args) {
    Solution sol = new Solution();
    int iterations = 1; // See table header for this value
    for (int i = 0; i < iterations; i++) {
        sol.isPowerOfThree(i);
    }
}
```
In the table below, the values are in seconds.
<img width="698" alt="Screen Shot 2023-05-16 at 10 48 38 PM" src="https://github.com/qifeibro/likou_note/assets/87322305/39eb7dd9-24f1-4fcd-8d12-604ce8b88a5b">

As we can see, for small values of N, the difference is not noticeable, but as we do more iterations and the values of  `n`  passed to  `isPowerOfThree()`  grow, we see significant boosts in performance for Approach 4.  
  

----------

#### Conclusion

Simple optimizations like this might seem negligible, but historically, when computation power was an issue, it allowed certain computer programs (such as Quake 3  [^4]) possible.  

----------

#### Similar Questions

[Power of Two](https://leetcode.com/problems/power-of-two/) Easy

[Power of Four](https://leetcode.com/problems/power-of-four/) Easy

[Check if Number is a Sum of Powers of Three](https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/) Medium

----------

#### Related Topics

[Math](https://leetcode.com/tag/math/) [Recursion](https://leetcode.com/tag/recursion/)

----------

#### Footnotes
[^1]: [http://www.cut-the-knot.org/recurrence/conversion.shtml](http://www.cut-the-knot.org/recurrence/conversion.shtml)  [↩](https://leetcode.com/problems/power-of-three/editorial/?orderBy=most_votes#user-content-fnref-note-4)
    
[^2]: [https://en.wikipedia.org/wiki/Regular_expression](https://en.wikipedia.org/wiki/Regular_expression)  [↩](https://leetcode.com/problems/power-of-three/editorial/?orderBy=most_votes#user-content-fnref-note-2)
    
[^3]: [http://developer.classpath.org/doc/java/lang/StrictMath-source.html](http://developer.classpath.org/doc/java/lang/StrictMath-source.html)  [↩](https://leetcode.com/problems/power-of-three/editorial/?orderBy=most_votes#user-content-fnref-note-3)
    
[^4]: [https://en.wikipedia.org/wiki/Fast_inverse_square_root](https://en.wikipedia.org/wiki/Fast_inverse_square_root)  [↩](https://leetcode.com/problems/power-of-three/editorial/?orderBy=most_votes#user-content-fnref-note-1)
