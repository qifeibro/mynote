#### [852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

难度中等

符合下列属性的数组  `arr`  称为  **山脉数组**  ：

-   `arr.length >= 3`
-   存在  `i`（`0 < i < arr.length - 1`）使得：
    -   `arr[0] < arr[1] < ... arr[i-1] < arr[i]`
    -   `arr[i] > arr[i+1] > ... > arr[arr.length - 1]`

给你由整数组成的山脉数组  `arr`  ，返回满足  `arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`  的下标  `i`  。

你必须设计并实现时间复杂度为  `O(log(n))`  的解决方案。

**示例 1：**
```
输入：arr = [0,1,0]
输出：1
```
**示例 2：**
```
输入：arr = [0,2,1,0]
输出：1
```
**示例 3：**
```
输入：arr = [0,10,5,2]
输出：1
```
**提示：**

-   `3 <= arr.length <= 10^5`
-   `0 <= arr[i] <= 10^6`
-   题目数据保证  `arr`  是一个山脉数组

[官方题解](https://leetcode.com/problems/peak-index-in-a-mountain-array/editorial/)

### Overview

Given a mountain array  `arr`, our task is to return the index  `i`  such that  `arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`. In simpler terms(简单来说), all elements to the left are sorted ascending(升序排列) and all elements to the right are sorted descending.

### Approach 1: Linear Scan(线性扫描)

#### Intuition

We are guaranteed to have an array of the form  `arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`. As our task is to find the index  `i`  (called the peak index of the mountain array), we can iterate over the array starting from the first element.

We can create a pointer  `i`  and set it to  `0`  to point to the first element. We compare the current element at index  `i`  with the next element at index  `i + 1`. If  `arr[i] < arr[i + 1]`, it means we haven't got the peak of the mountain yet. As a result, we increment  `i`  by  `1`  in this case to move to the next element. Otherwise, the first time we see  `arr[i] > arr[i + 1]`, we return  `i`.

#### Algorithm

1.  Create an integer variable  `i`  and initialize it to  `0`.
2.  Using a while loop check if the current element pointed by  `i`  is smaller than the next element at index  `i + 1`. If  `arr[i] < arr[i + 1]`, increment  `i`  by  `1`. Otherwise, if  `arr[i] > arr[i + 1]`, we return  `i`.

#### Implementation
```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int i = 0;
        while (arr[i] < arr[i + 1]) {
            i++;
        }
        return i;
    }
};
```
#### Complexity Analysis

Here  n  is the length of  `arr`.

-   Time complexity:  O(n).
    
    -   We are doing a linear scan and comparing adjacent elements(相邻元素) until we get the peak of the mountain over the  `arr`  array. In the worst-case situation, the peak of the mountain could correspond to the second last(倒数第二个) element of  `arr`, in which case we would take  O(n)  time.
-   Space complexity:  O(1).
    
    -   We are not using any extra space other than an integer  `i`, which takes up constant space.

### Approach 2: Binary Search

#### Intuition

In a mountain array with peak index  `i`, any element at  `index`  with  `index`  less than  `i`  would obey  `arr[index] < arr[index + 1]`. Furthermore, any  `index`  greater than or equal to  `i`  would follow the rule  `arr[index] > arr[index + 1]`  (and not obey  `arr[index] < arr[index + 1]`).

A scenario like this where our task is to search for an element  `i`  from a given range  `(l, r)`  where all values smaller than  `i`  satisfy a certain condition and all values greater than or equal to  `i`  do not satisfy it (or vice-versa) can be solved optimally with a binary search algorithm. In binary search, we repeatedly divide the solution space where the answer could be in half until the range contains just one element.

Following the above discussion, we use binary search to solve this problem. We create an integer  `l`  and initialize it to the starting index  `0`. We also create another integer variable  `r`  and set it to the last index of  `arr`, i.e.,  `arr.length - 1`.

We get the middle of the range  `mid = (l + r) / 2`  and compare  `arr[mid]`  with the next element. If  `arr[mid] < arr[mid + 1]`, we move to the upper half of the range by setting  `l = mid + 1`  as our peak index is definitely greater than  `mid`. Otherwise, if  `arr[mid] > arr[mid + 1]`, we move to the lower half of the range by setting  `r = mid`  as the peak index is either  `mid`  or some index smaller than  `mid`.

The answer would be within the range  `(l, r)`  at any point. All the indices smaller than  `l`  are indices smaller than the peak index and all indices greater than  `r`  are indices greater than the peak index. We continue the search as long as  `l < r`.

When  `l == r`,  `l`  (or  `r`) denotes the required peak index.

Here is a visual representation of an example to illustrate how it works:

![image](https://github.com/qifeibro/likou_note/assets/87322305/f45352f9-20a5-45e8-b6b8-3d6f325dc91d)

#### Algorithm

1.  Create two integer variables  `l`  and  `r`  to store the solution space of the problem. We initialize  `l`  with  `0`  and  `r`  to  `arr.length - 1`.
2.  While  `l < r`:
    -   Get the index of the middle element using  `mid = (l + r) / 2`.
    -   If  `arr[mid] < arr[mid + 1]`, it indicates peak index is greather than  `mid`. As a result, we move to upper half of the range by setting  `left = mid + 1`.
    -   Else, if  `arr[mid] >= arr[mid + 1]`, it indicates that the peak index is either  `mid`  or some index smaller than  `mid`. As a result, we move to the lower half of the range by setting  `r = mid`.
3.  Return  `l`  (or  `r`  as both are equal now).

#### Implementation
```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int l = 0, r = arr.size() - 1, mid;
        while (l < r) {
            mid = (l + r) / 2;
            if (arr[mid] < arr[mid + 1])
                l = mid + 1;
            else
                r = mid;
        }
        return l;
    }
};
```

#### Complexity Analysis

Here  n  is the length of  `arr`.

-   Time complexity:  O(logn).
    
    -   We perform  O(logn)  iterations using the binary search algorithm as the problem set is divided into half in each iteration.
-   Space complexity:  O(1).
    
    -   Except for a few variables  `l`,  `r`, and  `mid`  which take constant space each, we do not consume any other space.

[lee215题解](https://leetcode.com/problems/peak-index-in-a-mountain-array/solutions/139848/c-java-python-better-than-binary-search/)

### Approach 1, index of max, O(N)
```cpp
    int peakIndexInMountainArray(vector<int> A) {
       return max_element(A.begin(), A.end()) - A.begin();
    }
```

### Approach 2, For loop to find the first  `A[i] > A[i + i]`, O(N)
```cpp
    int peakIndexInMountainArray2(vector<int> A) {
        for (int i = 1; i + 1 < A.size(); ++i) if (A[i] > A[i + 1]) return i;
    }
```

**Follow-up:**  
Can you do faster than binary search?

### Approach 4, Golden-section search(黄金分割搜索)
和三分本质上是一样的：在logn的复杂度内来搜索单峰值函数的极值。区别只是取的三分点是0.666还是黄金分割点0.618

It's gurentee only one peak, we can apply golden-section search.
```python3
    def peakIndexInMountainArray(self, A):
        def gold1(l, r):
            return l + int(round((r - l) * 0.382))

        def gold2(l, r):
            return l + int(round((r - l) * 0.618))
        l, r = 0, len(A) - 1
        x1, x2 = gold1(l, r), gold2(l, r)
        while x1 < x2:
            if A[x1] < A[x2]:
                l = x1
                x1 = x2
                x2 = gold1(x1, r)
            else:
                r = x2
                x2 = x1
                x1 = gold2(l, x2)
        return A.index(max(A[l:r + 1]), l)
```

```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        double gr = (sqrt(5) + 1) / 2;
        int l = 0, r = arr.size() - 1;
        int m1 = r - int(round((r - l) / gr));
        int m2 = l + int(round((r - l) / gr));
        while (m1 < m2) {
            if (arr[m1] > arr[m2])
                r = m2;
            else
                l = m1;
            m1 = r - int(round((r - l) / gr));
            m2 = l + int(round((r - l) / gr));
        }
        return distance(arr.begin(), max_element(arr.begin() + l, arr.begin() + r + 1));
        // return max_element(arr.begin() + l, arr.begin() + r) - arr.begin();
    }
};
```

```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        double gr = (sqrt(5) + 1) / 2;
        int l = 0, r = arr.size() - 1;
        int goldenRatioOffset = round((r - l) / gr);
        int m1 = r - goldenRatioOffset;
        int m2 = l + goldenRatioOffset;
        while (m1 < m2) {
            if (arr[m1] > arr[m2])
                r = m2;
            else
                l = m1;
            goldenRatioOffset = round((r - l) / gr);
            m1 = r - goldenRatioOffset;
            m2 = l + goldenRatioOffset;
        }
        return max_element(arr.begin() + l, arr.begin() + r) - arr.begin();
    }
};
```

[宫水三叶题解](https://leetcode.cn/problems/peak-index-in-a-mountain-array/solution/gong-shui-san-xie-er-fen-san-fen-cha-zhi-5gfv/)

### 三分
**「三分」就是使用两个端点将区间分成三份，然后通过每次否决三分之一的区间来逼近目标值。**
具体的，由于峰顶元素为全局最大值，因此我们可以每次将当前区间分为[l, m1]、[m1, m2] 和 [m2, r] 三段，如果满足 arr[m1] > arr[m2]，说明峰顶元素不可能存在与 [m2, r] 中，让 r = m2 − 1 即可。另外一个区间分析同理。
```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n = arr.size();
        int l = 0, r = n - 1;
        while (l < r) {
            int m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;
            if (arr[m1] > arr[m2]) r = m2 - 1;                
            else l = m1 + 1;    
        }
        return r;
    }
};
```
-   时间复杂度： $O(log_3​n)$
-   空间复杂度： $O(1)$

#### 二分 & 三分 & k 分 ？

必须说明一点，「二分」和「三分」在渐进复杂度上都是一样的，都可以通过换底公式转化为可忽略的常数，因此两者的复杂度都是 O(logn)。

因此选择「二分」还是「三分」取决于要解决的是什么问题：
- 二分通常用来解决单调函数的找 target 问题，但进一步深入我们发现只需要满足「二段性」就能使用「二分」来找分割点；
- 三分则是解决单峰函数极值问题。

**因此一般我们将「通过比较两个端点，每次否决 1/3 区间 来解决单峰最值问题」的做法称为「三分」；而不是简单根据单次循环内将区间分为多少份来判定是否为「三分」。**

反例代码如下：
```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int left = 0, right = arr.length - 1;
        while(left < right) {
            int m1 = left + (right - left) / 3;
            int m2 = right - (right - left + 2) / 3;
            if (arr[m1] > arr[m1 + 1]) {
                right = m1;
            } else if (arr[m2] < arr[m2 + 1]) {
                left = m2 + 1;
            } else {
                left = m1; right = m2;
            }
        }
        return left;
    }
}
```
这并不是「三分」做法，最多称为「变形二分」。本质还是利用「二段性」来做分割的，只不过同时 check 了两个端点而已。

如果这算「三分」的话，那么我能在一次循环里面划分 k−1 个端点来实现 k 分？

**显然这是没有意义的，因为按照这种思路写出来的所谓的「四分」、「五分」、「k 分」是需要增加同等数量的分支判断的。这时候单次 while 决策就不能算作 O(1) 了，而是需要在 O(k) 的复杂度内决定在哪个分支，就跟上述代码有三个分支进行判断一样。** 因此，这种写法只能算作是「变形二分」。

**综上，只有「二分」和「三分」的概念，不存在所谓的 k 分。** 同时题解中的「三分」部分提供的做法就是标准的「三分」做法。

Similar Questions

[Find Peak Element](https://leetcode.com/problems/find-peak-element/) Medium

[Find in Mountain Array](https://leetcode.com/problems/find-in-mountain-array/) Hard

[Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/) Hard

----------

Related Topics

[Array](https://leetcode.com/tag/array/) [Binary Search](https://leetcode.com/tag/binary-search/)
